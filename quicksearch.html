<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.html":{"id":"global.html","title":"Global","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Global Members &lt;constant&gt; CLIENT CLIENT indicates that an identity is acting as a client &lt;constant&gt; HFAFFILIATIONMGR HFAFFILIATIONMGR is a boolean attribute that allows an identity to manage affiliations &lt;constant&gt; HFGENCRL HFGENCRL is an attribute that allows an identity to generate a CRL &lt;constant&gt; HFINTERMEDIATECA HFINTERMEDIATECA is a boolean attribute that allows an identity to enroll as an intermediate CA &lt;constant&gt; HFREGISTRARATTRIBUTES HFREGISTRARATTRIBUTES is an attribute that has a list of attributes that the registrar is allowed to register for an identity &lt;constant&gt; HFREGISTRARDELEGATEROLES HFREGISTRARDELEGATEROLES is an attribute that allows a registrar to give the roles specified to a registree for its 'hf.Registrar.Roles' attribute &lt;constant&gt; HFREGISTRARROLES HFREGISTRARROLES is an attribute that allows a registrar to manage identities of the specified roles &lt;constant&gt; HFREVOKER HFREVOKER is a boolean attribute that allows an identity to revoker a user and/or certificates &lt;constant&gt; ORDERER ORDERER indicates that an identity is acting as an orderer &lt;constant&gt; PEER PEER indicates that an identity is acting as a peer &lt;constant&gt; USER USER indicates that an identity is acting as a user Methods package(chaincodePath, chaincodeType, devmode, metadataPath) Utility function to package a chaincode. The contents will be returned as a byte array. Parameters: Name Type Description chaincodePath string required - String of the path to location of the source code of the chaincode chaincodeType string String of the type of chaincode ['golang', 'node', 'car', 'java'] (default 'golang') devmode boolean Set to true to use chaincode development mode metadataPath string Optional. The path to the top-level directory containing metadata descriptors Returns: A promise for the data as a byte array Type Promise Type Definitions AffiliationRequest Type: Object Properties: Name Type Description name string Required. The affiliation path to create caname string Optional. Name of the CA to send the request to within the Fabric CA server force boolean Optional. For create affiliation request, if any of the parent affiliations do not exist and 'force' is true, create all parent affiliations also. For delete affiliation request, if force is true and there are any child affiliations or any identities are associated with this affiliation or child affiliations, these identities and child affiliations will be deleted; otherwise, an error is returned. For update affiliation request, if any identities are associated with this affiliation, 'force' is true causes these identities' affiliations to be renamed; otherwise, an error is returned. AttributeRequest Type: Object Properties: Name Type Description name string The name of the attribute to include in the certificate optional boolean throw an error if the identity does not have the attribute Block An object of a fully decoded protobuf message &quot;Block&quot;. A Block may contain the configuration of the channel or transactions on the channel. A Block object will have the following object structure. header number -- {int} previous_hash -- {byte[]} data_hash -- {byte[]} data data -- {array} signature -- {byte[]} payload header -- {Header} data -- {ConfigEnvelope | Transaction} metadata metadata -- {array} #each array item has it's own layout [0] #SIGNATURES signatures -- {MetadataSignature[]} [1] #LAST_CONFIG value index -- {number} signatures -- {MetadataSignature[]} [2] #TRANSACTIONS_FILTER {int[]} #see TxValidationCode in proto/peer/transaction.proto Type: Object Examples Get the block number: var block_num = block.header.number; Get the number of transactions, including the invalid transactions: var block_num = block.data.data.legnth; Get the Id of the first transaction in the block: var tx_id = block.data.data[0].payload.header.channel_header.tx_id; BlockchainInfo Type: Object Properties: Name Type Description height number How many blocks exist on the channel's ledger currentBlockHash Array.&lt;byte&gt; A block hash is calculated by hashing over the concatenated ASN.1 encoded bytes of: the block number, previous block hash, and current block data hash. It's the chain of the block hashs that guarantees the immutability of the ledger previousBlockHash Array.&lt;byte&gt; The block hash of the previous block. BroadcastResponse Type: Object Properties: Name Type Description status string Value is 'SUCCESS' or a descriptive error string ChaincodeEvent Type: Object Properties: Name Type Description chaincode_id string tx_id string event_name string payload Array.&lt;byte&gt; Application-specific byte array that the chaincode set when it called stub.SetEvent(event_name, payload) ChaincodeEvent Type: Object Properties: Name Type Description chaincode_id string tx_id string event_name string payload Array.&lt;byte&gt; Application-specific byte array that the chaincode set when it called stub.SetEvent(event_name, payload) ChaincodeInfo Type: Object Properties: Name Type Description name string version string path string the path as specified by the install/instantiate transaction input string the chaincode function upon instantiation and its arguments. This will be blank if the query is returning information about installed chaincodes. escc string the name of the ESCC for this chaincode. This will be blank if the query is returning information about installed chaincodes. vscc string the name of the VSCC for this chaincode. This will be blank if the query is returning information about installed chaincodes. ChaincodeInstallRequest Type: Object Properties: Name Type Description targets Array.&lt;Peer&gt; Optional. An array of Peer objects where the chaincode will be installed. When excluded, the peers assigned to this client's organization will be used as defined in the network configuration. If the 'channelNames' property is included, the target peers will be based the peers defined in the channels. chaincodePath string Required. The path to the location of the source code of the chaincode. If the chaincode type is golang, then this path is the fully qualified package name, such as 'mycompany.com/myproject/mypackage/mychaincode' metadataPath string Optional. The path to the top-level directory containing metadata descriptors. chaincodeId string Required. Name of the chaincode chaincodeVersion string Required. Version string of the chaincode, such as 'v1' chaincodePackage Array.&lt;byte&gt; Optional. Byte array of the archive content for the chaincode source. The archive must have a 'src' folder containing subfolders corresponding to the 'chaincodePath' field. For instance, if the chaincodePath is 'mycompany.com/myproject/mypackage/mychaincode', then the archive must contain a folder 'src/mycompany.com/myproject/mypackage/mychaincode', where the chaincode source code resides. chaincodeType string Optional. Type of chaincode. One of 'golang', 'car', 'node' or 'java'. Default is 'golang'. Note that 'java' is not supported as of v1.0. channelNames Array.&lt;string&gt; | string Optional. When no targets are provided. The loaded network configuration will be searched for suitable target peers. Peers that are defined in the channels named by this property and in this client's organization and that are in the endorsing or chain code query role on the named channel will be selected. ChaincodeInstantiateUpgradeRequest Type: Object Properties: Name Type Description targets Array.&lt;Peer&gt; Optional. An array of endorsing Peer objects as the targets of the request. When this parameter is omitted the target list will include peers assigned to this channel instance that are in the endorsing role. chaincodeType string Optional. Type of chaincode. One of 'golang', 'car', 'java' or 'node'. Default is 'golang'. Note that 'java' is not supported as of v1.0. chaincodeId string Required. The name of the chaincode chaincodeVersion string Required. Version string of the chaincode, such as 'v1' txId TransactionID Required. Object with the transaction id and nonce transientMap map Optional. map that can be used by the chaincode during intialization, but not saved in the ledger. Data such as cryptographic information for encryption can be passed to the chaincode using this technique. fcn string Optional. The function name to be returned when calling stub.GetFunctionAndParameters() in the target chaincode. Default is 'init'. args Array.&lt;string&gt; Optional. Array of string arguments to pass to the function identified by the fcn value. endorsement-policy Object Optional. EndorsementPolicy object for this chaincode (see examples below). If not specified, a default policy of &quot;a signature by any member from any of the organizations corresponding to the array of member service providers&quot; is used. WARNING: The default policy is NOT recommended for production, because this allows an application to bypass the proposal endorsement and send a manually constructed transaction, with arbitrary output in the write set, to the orderer directly. An application's own signature would allow the transaction to be successfully validated and committed to the ledger. Examples Endorsement policy: &quot;Signed by any member from one of the organizations&quot; { identities: [ { role: { name: &quot;member&quot;, mspId: &quot;org1&quot; }}, { role: { name: &quot;member&quot;, mspId: &quot;org2&quot; }} ], policy: { &quot;1-of&quot;: [{ &quot;signed-by&quot;: 0 }, { &quot;signed-by&quot;: 1 }] } } Endorsement policy: &quot;Signed by admin of the ordererOrg and any member from one of the peer organizations&quot; { identities: [ { role: { name: &quot;member&quot;, mspId: &quot;peerOrg1&quot; }}, { role: { name: &quot;member&quot;, mspId: &quot;peerOrg2&quot; }}, { role: { name: &quot;admin&quot;, mspId: &quot;ordererOrg&quot; }} ], policy: { &quot;2-of&quot;: [ { &quot;signed-by&quot;: 2}, { &quot;1-of&quot;: [{ &quot;signed-by&quot;: 0 }, { &quot;signed-by&quot;: 1 }]} ] } } ChaincodeInvokeRequest Type: Object Properties: Name Type Description targets Array.&lt;Peer&gt; Optional. The peers that will receive this request, when not provided the list of peers added to this channel object will be used. chaincodeId string Required. The id of the chaincode to process the transaction proposal txId TransactionID Required. TransactionID object with the transaction id and nonce transientMap map Optional. map that can be used by the chaincode but not saved in the ledger, such as cryptographic information for encryption fcn string Optional. The function name to be returned when calling stub.GetFunctionAndParameters() in the target chaincode. Default is 'invoke' args Array.&lt;string&gt; An array of string arguments specific to the chaincode's 'Invoke' method ChaincodeQueryRequest Type: Object Properties: Name Type Description targets Array.&lt;Peer&gt; Optional. The peers that will receive this request, when not provided the list of peers added to this channel object will be used. chaincodeId string Required. The id of the chaincode to process the transaction proposal transientMap map Optional. map that can be used by the chaincode but not saved in the ledger, such as cryptographic information for encryption fcn string Optional. The function name to be returned when calling stub.GetFunctionAndParameters() in the target chaincode. Default is 'invoke' args Array.&lt;string&gt; An array of string arguments specific to the chaincode's 'Invoke' method ChaincodeQueryResponse Type: Object Properties: Name Type Description chaincodes Array.&lt;ChaincodeInfo&gt; ChannelConfigGroup The configuration settings that govern how the fabric should maintain a channel are included in the blocks of the channel itself. When a block contains the channel configuration, the channel configuration record is the only item in the block's data array. Every block, including the configuration blocks themselves, has a pointer to the latest configuration block, making it easy to query for the latest channel configuration settings. A channel configuration record will have the following object structure. version -- {int} mod_policy -- {string} groups Orderer version -- {int} groups &lt;orderer_org_name&gt; -- {OrganizationConfigGroup} values ConsensusType version -- {int} mod_policy -- {string} value type -- {string} BatchSize version -- {int} mod_policy -- {string} value max_message_count -- {int} absolute_max_bytes -- {int} preferred_max_bytes -- {int} BatchTimeout version -- {int} mod_policy -- {string} value timeout -- {duration} ChannelRestrictions version -- {int} mod_policy -- {string} value max_count -- {int} policies Admins version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} Writers version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} Readers version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} BlockValidation version -- {int} mod_policy -- {string} policy -- {SignaturePolicy} Application version -- {int} groups &lt;peer_org_name&gt; -- {OrganizationConfigGroup} values policies Admins version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} Writers version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} Readers version -- {int} mod_policy -- {string} policy -- {ImplicitMetaPolicy} values OrdererAddresses version -- {int} mod_policy -- {string} value addresses -- {array} {string - host:port} HashingAlgorithm version -- {int} mod_policy -- {string} value name -- {string} BlockDataHashingStructure version -- {int} mod_policy -- {string} value width -- {int} Consortium version -- {int} mod_policy -- {string} value name -- {string} Type: Object Properties: Name Type Description groups.Orderer.groups.&lt;orderer_org_name&gt; OrganizationConfigGroup These are the orderer organizatoin names defined on the network groups.Application.groups.&lt;peer_org_name&gt; OrganizationConfigGroup These are the peer organization names defined on the network policy ImplicitMetaPolicy These policies point to other policies and specify a threshold as in &quot;ANY&quot;, &quot;MAJORITY&quot; or &quot;ALL&quot; ChannelInfo Type: Object Properties: Name Type Description channel_id string ChannelQueryResponse Type: Object Properties: Name Type Description channels Array.&lt;ChannelInfo&gt; ChannelRequest Type: Object Properties: Name Type Description name string Required. The name of the new channel orderer Orderer Required. An Orderer object representing the orderer node to send the channel create request envelope Array.&lt;byte&gt; Optional. Bytes of the envelope object containing all required settings and signatures to initialize this channel. This envelope would have been created by the command line tool configtxgen or configtxlator config Array.&lt;byte&gt; Optional. Protobuf ConfigUpdate object extracted from a ConfigEnvelope created by the configtxgen tool. See extractChannelConfig(). The ConfigUpdate object may also be created by the configtxlator tool. signatures Array.&lt;ConfigSignature&gt; Required. The list of signatures required by the channel creation or update policy when using the `config` parameter. txId TransactionID Required. TransactionID object with the transaction id and nonce ConfigEnvelope A ConfigEnvelope contains the channel configurations data and is the main content of a configuration block. Another type of blocks are those that contain endorser transactions, where the main content is an array of Transaction. A &quot;ConfigEnvelope&quot; will have the following object structure. config sequence -- {int} channel_group -- {ConfigGroup} type -- {int} last_update signature -- {byte[]} payload header -- {Header} data -- {ConfigUpdateEnvelope} Type: Object ConfigSignature Type: Object Properties: Name Type Description signature_header Array.&lt;byte&gt; Encoded bytes of a SignatureHeader signature Array.&lt;byte&gt; Encoded bytes of the signature over the concatenation of the signatureHeader bytes and config bytes ConfigUpdateEnvelope An object of a protobuf message &quot;ConfigUpdateEnvelope&quot;. A &quot;ConfigUpdateEnvelope&quot; will have the following object structure. config_update channel_id -- {string} read_set -- {ChannelConfigGroup} write_set -- {ChannelConfigGroup} type -- {int} signatures -- {array} signature_header -- {SignatureHeader} signature -- {byte[]} Type: Object Properties: Name Type Description config_update.read_set ChannelConfigGroup A set of the current version numbers of all configuration items being updated config_update.write_set ChannelConfigGroup A set of all configuration items being updated. Must have a version number one greater than the version number of the same item in the read_set along with the new value. ConnectionOpts Type: Object Properties: Name Type Description request-timeout string An integer value in milliseconds to be used as maximum amount of time to wait on the request to respond. pem string The certificate file, in PEM format, to use with the gRPC protocol (that is, with TransportCredentials). Required when using the grpcs protocol. ssl-target-name-override string Used in test environment only, when the server certificate's hostname (in the 'CN' field) does not match the actual host endpoint that the server process runs at, the application can work around the client TLS verify failure by setting this property to the value of the server certificate's hostname &lt;any&gt; any any other standard grpc call options will be passed to the grpc service calls directly CouchDBOpts Type: Object Properties: Name Type Description url string The CouchDB instance url, in the form of http(s)://:@host:port name string Optional. Identifies the name of the database to use. Default: member_db. CryptoContent Type: Object Properties: Name Type Description privateKey string the PEM file path for the private key privateKeyPEM string the PEM string for the private key (not required if privateKey or privateKeyObj is set) privateKeyObj module:api.Key private key object (not required if privateKey or privateKeyPEM is set) signedCert string the PEM file path for the certificate signedCertPEM string the PEM string for the certificate (not required if signedCert is set) CryptoSetting Type: Object Properties: Name Type Description software boolean Whether to load a software-based implementation (true) or HSM implementation (false) default is true (for software based implementation), specific implementation module is specified in the setting 'crypto-suite-software' keysize number The key size to use for the crypto suite instance. default is value of the setting 'crypto-keysize' algorithm string Digital signature algorithm, currently supporting ECDSA only with value 'EC' hash string 'SHA2' or 'SHA3' Endorsement An endorsement is a signature of an endorser over a proposal response. By producing an endorsement message, an endorser implicitly &quot;approves&quot; that proposal response and the actions contained therein. When enough endorsements have been collected, a transaction can be generated out of a set of proposal responses An endorsement message has the following structure: endorser Mspid -- {string] IdBytes -- {byte[]} signature -- {byte[]} Type: Object EnrollmentRequest Type: Object Properties: Name Type Description enrollmentID string The registered ID to use for enrollment enrollmentSecret string The secret associated with the enrollment ID profile string The profile name. Specify the 'tls' profile for a TLS certificate; otherwise, an enrollment certificate is issued. attr_reqs Array.&lt;AttributeRequest&gt; An array of AttributeRequest EnrollmentResponse Type: Object Properties: Name Type Description enrollmentCert string PEM-encoded X509 enrollment certificate caCertChain string PEM-encoded X509 certificate chain for the issuing certificate authority EventRegistrationRequest Type: Object Header Headers describe basic information about a transaction record, such as its type (configuration update, or endorser transaction, etc.), the id of the channel it belongs to, the transaction id and so on. The header message also contains a common field SignatureHeader that describes critical information about how to verify signatures. A &quot;Header&quot; will have the following object structure. channel_header type -- {string} version -- {int} timestamp -- {time} channel_id -- {string} tx_id -- {string} epoch -- {int} signature_header -- {SignatureHeader} Type: Object HTTPEndpoint Type: Object Properties: Name Type Description hostname string port number protocol string Identity Type: Object Properties: Name Type Description role Role Any identity of a particular role OrganizationUnit Any identities belonging to an organization unit per certificate chain of trust Identity A specific identity IdentityRequest Type: Object Properties: Name Type Description enrollmentID string Required. The enrollment ID which uniquely identifies an identity affiliation string Required. The affiliation path of the new identity attrs Array.&lt;KeyValueAttribute&gt; Array of KeyValueAttribute attributes to assign to the user type string Optional. The type of the identity (e.g. *user*, *app*, *peer*, *orderer*, etc) enrollmentSecret string Optional. The enrollment secret. If not provided, a random secret is generated. maxEnrollments number Optional. The maximum number of times that the secret can be used to enroll. If 0, use the configured max_enrollments of the fabric-ca-server; If &gt; 0 and configured max enrollments of the fabric-ca-server, error. caname string Optional. Name of the CA to send the request to within the Fabric CA server ImplicitMetaPolicy ImplicitMetaPolicy is a policy type which depends on the hierarchical nature of the configuration It is implicit because the rule is generate implicitly based on the number of sub policies It is meta because it depends only on the result of other policies When evaluated, this policy iterates over all immediate child sub-groups, retrieves the policy of name sub_policy, evaluates the collection and applies the rule. For example, with 4 sub-groups, and a policy name of &quot;Readers&quot;, ImplicitMetaPolicy retrieves each sub-group, retrieves policy &quot;Readers&quot; for each subgroup, evaluates it, and, in the case of ANY 1 satisfied is sufficient, ALL would require 4 signatures, and MAJORITY would require 3 signatures. An &quot;ImplicitMetaPolicy&quot; will have the following object structure. type -- IMPLICIT_META policy sub_policy -- {string} rule -- ANY | ALL | MAJORITY Type: Object JoinChannelRequest Type: Object Properties: Name Type Description targets Array.&lt;Peer&gt; Optional. An array of Peer objects or Peer names that will be asked to join this channel. When using Peer names or left empty (use default targets) there must be a loaded network configuration. See loadFromConfig() block Array.&lt;byte&gt; The encoded bytes of the channel's genesis block. See getGenesisBlock() method txId TransactionID Required. TransactionID object with the transaction id and nonce KeyOpts Options for a key operation Type: Object Properties: Name Type Description ephemeral boolean Whether the key should be persisted. &quot;true&quot; to persist. KeyValueAttribute Type: Object Properties: Name Type Description name string The key used to reference the attribute value string The value of the attribute ecert boolean Optional, A value of true indicates that this attribute should be included in an enrollment certificate by default MetadataSignature A signature over the metadata of a block, to ensure the authenticity of the metadata that describes a Block. signature_header {SignatureHeader} signature -- {byte[]} Type: Object OrdererRequest Type: Object Properties: Name Type Description txId TransactionID Optional. Object with the transaction id and nonce orderer Orderer Optional. The orderer instance or string name of the orderer to retrieve genesis block from OrganizationConfigGroup Each participating organization of the channel gets represented in a section in the configuration block as described below. Critical information about the organzation such as its Membership Service Provider (MSP) content and its pre-defined policies that form the basis of the channel's access control policies (Admins, Writers and Readers) are contained in these sections. A organizational configuration will have the following object structure. version -- {int} mod_policy -- {string} values MSP version -- {int} mod_policy -- {string} value type -- {int} config name -- {string} root_certs -- {string[]} intermediate_certs -- {string[]} admins -- {string[]} revocation_list -- {string[]} signing_identity -- {byte[]} organizational_unit_identifiers -- {string[]} policies Admins version -- {int} mod_policy -- {string} policy -- {SignaturePolicy} Writers version -- {int} mod_policy -- {string} policy -- {SignaturePolicy} Readers version -- {int} mod_policy -- {string} policy -- {SignaturePolicy} Type: Object Policy Defines the endorsement policies Type: Object Properties: Name Type Description identities Array.&lt;Identity&gt; List of identities to be referenced in the &quot;policy&quot; section policy Array.&lt;PolicySpec&gt; The specification of the policy using a combination of &quot;signed-by&quot; and &quot;n-of&quot; structures. The design allows recursion PolicySpec Type: Object Properties: Name Type Description type Object The type of policy can be &quot;signed-by&quot; for a single identity signature or &quot;n-of&quot; where &quot;n&quot; is a numeric value. If the type property is &quot;signed-by&quot;, the value is the numeric index into the array of identities specified in the policy. If the type property is &quot;n-of&quot;, the value is an array of PolicySpec objects. As you can see, this structure allows recursive definitions of complex policies. ProcessedTransaction Type: Object Properties: Name Type Description validationCode number See this list for all the defined validation codes transactionEnvelope Object Encapsulates the transaction and the signature over it. It has the following structure: signature -- {byte[]} payload -- {} header -- {Header} data -- {Transaction} ProposalResponse A protobuf message that gets returned by endorsing peers on proposal requests. The peer node runs the target chaincode, as designated by the proposal, and decides on whether to endorse the proposal or not, and sends back the endorsement result along with the read and write sets inside the proposal response message. Type: Object Properties: Name Type Description version number timestamp Timestamp Time the proposal was created by the submitter response Response payload Array.&lt;byte&gt; The payload of the response. It is the encoded bytes of the &quot;ProposalResponsePayload&quot; protobuf message endorsement Endorsement The endorsement of the proposal, basically the endorser's signature over the payload ProposalResponseObject All calls to the endorsing peers for proposal endorsement return this standard array of objects. Type: array Properties: Name Type Description index:0 array Array of ProposalResponse objects from the endorsing peers index:1 Object The original Proposal object needed when sending the transaction request to the orderer RegisterRequest Type: Object Properties: Name Type Description enrollmentID string ID which will be used for enrollment enrollmentSecret string Optional enrollment secret to set for the registered user. If not provided, the server will generate one. role string Optional arbitrary string representing a role value for the user affiliation string Affiliation with which this user will be associated, like a company or an organization maxEnrollments number The maximum number of times this user will be permitted to enroll attrs Array.&lt;KeyValueAttribute&gt; Array of KeyValueAttribute attributes to assign to the user RegistrationOpts Type: Object Properties: Name Type Description startBlock integer Optional - The starting block number for event checking. When included, the peer's channel event service will be asked to start sending blocks from this block number. This is how to resume or replay missed blocks that were added to the ledger. Default is the latest block on the ledger. Setting a startBlock may confuse other event listeners, therefore only one listener will be allowed on a ChannelEventHub when a startBlock is being used. endBlock integer Optional - The ending block number for event checking. When included, the peer's channel event service will be asked to stop sending blocks once this block is delivered. This is how to replay missed blocks that were added to the ledger. When a startBlock is not included, the endBlock must be equal to or larger the current channel block height. Setting an endBlock may confuse other event listeners, therefore only one listener will be allowed on a ChannelEventHub when an endBlock is being used. unregister boolean Optional - This options setting indicates the registration should be removed (unregister) when the event is seen. When the application is using a timeout to only wait a specified amount of time for the transaction to be seen, the timeout processing should included the manual 'unregister' of the transaction event listener to avoid the event callbacks being called unexpectedly. The default for this setting is different for the different type of event listeners. For block listeners the default is true, however the event listener is assumed to have seen the final event only if the end_block was set as a option and that end_block was seen by the the listener. For transaction listeners the default is true and the listener will be unregistered when a transaction with the id is seen by this listener. For chaincode listeners the default will be false as the match filter might be intended for many transactions rather than a specific transaction or block as in the other listeners. disconnect boolean Optional - This option setting Indicates to the ChannelEventHub instance to automatically disconnect itself from the peer's channel event service once the event has been seen. The default is false unless the endBlock has been set, then it it will be true. Response A response message indicating whether the endorsement of the proposal was successful Type: Object Properties: Name Type Description status number Status code. Follows HTTP status code definitions message string A message associated with the response status code payload Array.&lt;byte&gt; A payload that can be used to include metadata with this response Restriction Type: Object Properties: Name Type Description revokedBefore Date Include certificates that were revoked before this UTC timestamp (in RFC3339 format) in the CRL revokedAfter Date Include certificates that were revoked after this UTC timestamp (in RFC3339 format) in the CRL expireBefore Date Include revoked certificates that expire before this UTC timestamp (in RFC3339 format) in the CRL expireAfter Date Include revoked certificates that expire after this UTC timestamp (in RFC3339 format) in the CRL Role Type: Object Properties: Name Type Description name string Name of the role. Value can be &quot;member&quot; or &quot;admin&quot; mspId string The member service provider Id used to process the identity ServiceResponse Type: Object Properties: Name Type Description Success boolean Boolean indicating if the request was successful Result Object The result of this request Errors Array.&lt;ServiceResponseMessage&gt; An array of error messages (code and message) Messages Array.&lt;ServiceResponseMessage&gt; An array of information messages (code and message) ServiceResponseMessage Type: Object Properties: Name Type Description code number Integer code denoting the type of message message string A more specific message SignatureHeader An object that is part of all signatures in Hyperledger Fabric. The &quot;creator&quot; field has two important pieces of information about the identity of the signer, the organization (Mspid) that the signer belongs to, and the certificate (IdBytes). The &quot;nonce&quot; field is a unique value to guard against replay attacks. creator Mspid -- {string} IdBytes -- {byte[]} nonce -- {byte[]} Type: Object SignaturePolicy SignaturePolicy is a recursive message structure which defines a featherweight DSL for describing policies which are more complicated than 'exactly this signature'. The NOutOf operator is sufficent to express AND as well as OR, as well as of course N out of the following M policies. SignedBy implies that the signature is from a valid certificate which is signed by the trusted authority specified in the bytes. This will be the certificate itself for a self-signed certificate and will be the CA for more traditional certificates A &quot;SignaturePolicy&quot; will have the following object structure. type -- SIGNATURE rule Type -- n_out_of n_out_of N -- {int} rules -- {array} Type -- signed_by signed_by -- {int} identities -- {array} principal_classification -- {int} msp_identifier -- {string} Role -- MEMBER | ADMIN Type: Object TLSOptions Type: Object Properties: Name Type Argument Default Description trustedRoots Array.&lt;string&gt; Array of PEM-encoded trusted root certificates verify boolean &lt;optional&gt; true Determines whether or not to verify the server certificate when using TLS Transaction A Transaction, or &quot;Endorser Transaction&quot;, is the result of invoking chaincodes to collect endorsements, getting globally ordered in the context of a channel, and getting validated by the committer peer as part of a block before finally being formally &quot;committed&quot; to the ledger inside a Block. Each transaction contains an array of &quot;actions&quot; representing different steps for executing a transaction, and those steps will be processed atomically, meaning if any one step failed then the whole transaction will be marked as rejected. Each entry of the &quot;actions&quot; array contains a chaincode proposal and corresponding proposal responses that encapsulate the endorsing peer's decisions on whether the proposal is considered valid. Note that even if a transaction proposal(s) is considered valid by the endorsing peers, it may still be rejected by the committers during transaction validation. Whether a transaction as a whole is valid or not, is not reflected in the transaction record itself, but rather recorded in a separate field in the Block's metadata. A &quot;Transaction&quot; will have the following object structure. actions {array} header -- {SignatureHeader} payload chaincode_proposal_payload input -- {byte[]} action proposal_response_payload proposal_hash -- {byte[]} extension results data_model -- {int} ns_rwset -- {array} namespace -- {string} rwset reads -- {array} key -- {string} version block_num -- {number} tx_num -- {number} range_queries_info -- {array} writes -- {array} key -- {string} is_delete -- {boolean} value -- {string} events chaincode_id -- {string} tx_id -- {string} event_name -- {string} payload -- {byte[]} response status -- {int} message -- {string} payload -- {byte[]} endorsements -- {Endorsement[]} Type: Object TransactionRequest Type: Object Properties: Name Type Description proposalResponses array An array of or a single ProposalResponse object containing the response from the endorsement call proposal Object A Proposal object containing the original request for endorsement(s) txID Object Optional. - Must be the transaction ID object used in the proposal endorsement. The transactionID will only be used to determine if the signing of the request should be done by the admin identity or the user assigned to the client instance. UserNamePasswordObject An alternate object to use on the 'setUserContext' call in place of the 'User' object. When using this object it is assumed that the current 'Client' instance has been loaded with a network configuration. Type: Object Properties: Name Type Description username string A string representing the user name of the user password string A string repsesenting the password of the user UserOpts Type: Object Properties: Name Type Description username string {string} - the user name used for enrollment mspid string {string} - the MSP id cryptoContent CryptoContent the private key and certificate skipPersistence boolean whether to save this new user object into persistence. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:04+00:00 using the DocStrap template. "},"modules.list.html":{"id":"modules.list.html","title":"Modules","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Modules Classes AffiliationService BaseClient BasePackager BlockDecoder CertificateAuthority Channel ChannelEventHub Client CouchDBKeyValueStore CryptoKeyStore CryptoSuite_ECDSA_AES CryptoSuite_PKCS11 ECDSA_KEY EndorsementPolicy EventHub FabricCAClient FabricCAServices FileKeyValueStore Identity IdentityService exports CryptoSuite Key KeyValueStore MSP MSPManager NetworkConfig_1_0 Orderer Organization Peer PKCS11_ECDSA_KEY Remote Signer SigningIdentity TransactionID User × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Classes Classes AffiliationService BaseClient BasePackager BlockDecoder CertificateAuthority Channel ChannelEventHub Client CouchDBKeyValueStore CryptoKeyStore CryptoSuite_ECDSA_AES CryptoSuite_PKCS11 ECDSA_KEY EndorsementPolicy EventHub FabricCAClient FabricCAServices FileKeyValueStore Identity IdentityService exports CryptoSuite Key KeyValueStore MSP MSPManager NetworkConfig_1_0 Orderer Organization Peer PKCS11_ECDSA_KEY Remote Signer SigningIdentity TransactionID User × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"tutorials.list.html":{"id":"tutorials.list.html","title":"Tutorials","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Tutorials Classes AffiliationService BaseClient BasePackager BlockDecoder CertificateAuthority Channel ChannelEventHub Client CouchDBKeyValueStore CryptoKeyStore CryptoSuite_ECDSA_AES CryptoSuite_PKCS11 ECDSA_KEY EndorsementPolicy EventHub FabricCAClient FabricCAServices FileKeyValueStore Identity IdentityService exports CryptoSuite Key KeyValueStore MSP MSPManager NetworkConfig_1_0 Orderer Organization Peer PKCS11_ECDSA_KEY Remote Signer SigningIdentity TransactionID User × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"index.html":{"id":"index.html","title":"Index","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER The Hyperledger Fabric SDK for Node.js provides a powerful API to interact with a Hyperledger Fabric v1.0 blockchain. The SDK is designed to be used in the Node.js JavaScript runtime. OverviewHyperledger Fabric is the operating system of an enterprise-strength permissioned blockchain network. For a high-level overview of the fabric, visit http://hyperledger-fabric.readthedocs.io/en/latest/. Applications can be developed to interact with the blockchain network on behalf of the users. APIs are available to: create channels ask peer nodes to join the channel install chaincodes in peers instantiate chaincodes in a channel invoke transactions by calling the chaincode query the ledger for transactions or blocks How Different Components of the Fabric Work TogetherThe Transaction Flow document provides an excellent description of the application/SDK, peers, and orderers working together to process transactions and producing blocks. Security on the Fabric is enforced with digital signatures. All requests made to the fabric must be signed by users with appropriate enrollment certificates. For a user's enrollment certificate to be considered valid on the Fabric, it must be signed by a trusted Certificate Authority (CA). Fabric supports any standard CAs. In addition, Fabric provides a CA server. See this overview. Features of the SDK for Node.jsThe Hyperledger Fabric SDK for Node.js is designed in an Object-Oriented programming style. Its modular construction enables application developers to plug in alternative implementations of key functions such as crypto suites, the state persistence store, and logging utility. The SDK's list of features include: fabric-client: create a new channel send channel information to a peer to join install chaincode on a peer instantiate chaincode in a channel, which involves two steps: propose and transact submitting a transaction, which also involves two steps: propose and transact query a chaincode for the latest application state various query capabilities: channel height block-by-number, block-by-hash all channels that a peer is part of all installed chaincodes in a peer all instantiated chaincodes in a channel transaction-by-id channel configuration data monitoring events: connect to a peer's event stream listen on block events listen on transactions events and find out if the transaction was successfully committed to the ledger or marked invalid listen on custom events produced by chaincodes serializable User object with signing capabilities hierarchical configuration settings with multiple layers of overrides: files, environment variable, program arguments, in-memory settings logging utility with a built-in logger (winston) and can be overriden with a number of popular loggers including log4js and bunyan pluggable CryptoSuite interface describe the cryptographic operations required for successful interactions with the Fabric. Two implementations are provided out of box: Software-based ECDSA PKCS#11-compliant ECDSA pluggable State Store interface for persisting state caches such as users File-based store CouchDB-base store which works with both CouchDB database and IBM Cloudant customizable Crypto Key Store for any software-based cryptographic suite implementation supports both TLS (grpcs://) or non-TLS (grpc://) connections to peers and orderers, see Remote which is the superclass for peers and orderers fabric-ca-client: register a new user enroll a user to obtain the enrollment certificate signed by the Fabric CA revoke an existing user by enrollment ID or revoke a specific certificate customizable persistence store API ReferenceThe SDK is made up of 3 top-level modules that can be accessed through the navigation menu Modules: api: pluggable APIs for application developers to supply alternative implementations of key interfaces used by the SDK. For each interface there are built-in default implementations. fabric-client: this module provides APIs to interact with the core components of a Hypreledger Fabric-based blockchain network, namely the peers, orderers and event streams. fabric-ca-client: this module provides APIs to interact with the optional component, fabric-ca, that contains services for membership management. This work is licensed under a Creative Commons Attribution 4.0 International License. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"AffiliationService.html":{"id":"AffiliationService.html","title":"Class: AffiliationService","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: AffiliationService AffiliationService This is an implementation of the Affiliation service which communicates with the Fabric CA server using the Fabric CA client FabricCAClient. new AffiliationService() Methods create(req, registrar) Create a new affiliation. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description req AffiliationRequest Required. The AffiliationRequest registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise delete(req, registrar) Delete an affiliation. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description req AffiliationRequest Required. The AffiliationRequest registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise getAll(registrar) List all affiliations equal to and below the caller's affiliation. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise getOne(affiliation, registrar) List a specific affiliation at or below the caller's affinity. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description affiliation string The affiliation path to be queried. registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise update(affiliation, req, registrar) Rename an affiliation. The caller must have hf.AffiliationMgr authority. Parameters: Name Type Description affiliation string The affiliation path to be updated req AffiliationRequest Required. The AffiliationRequest registrar User Returns: ServiceResponse Type Promise × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"BaseClient.html":{"id":"BaseClient.html","title":"Class: BaseClient","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: BaseClient BaseClient Base class for a client that can use a CryptoSuite to sign and hash. It also contains utility methods for constructing new instances of CryptoKeyStore, CryptoSuite and KeyValueStore new BaseClient() Methods &lt;static&gt; addConfigFile(path) Adds a file to the top of the list of configuration setting files that are part of the hierarchical configuration. These files will override the default settings and be overriden by environment, command line arguments, and settings programmatically set into configuration settings. The hierarchical configuration settings search order: see BaseClient.getConfigSetting Parameters: Name Type Description path String The path to the file to be added to the top of list of configuration files &lt;static&gt; getConfigSetting(name, default_value) Retrieves a setting from the hierarchical configuration and if not found will return the provided default value. The hierarchical configuration settings search order for a setting aa-bb: memory: if the setting has been added with Client.setConfigSetting('aa-bb', 'value') Command-line arguments: like node app.js --aa-bb value Environment variables: AA_BB=value node app.js Custom Files: all files added with addConfigFile(path) will be ordered by when added, where same settings in the files added later will override those added earlier The file located at lib/config/default.json with default settings Parameters: Name Type Description name String The name of a setting default_value Object The value of a setting if not found in the hierarchical configuration &lt;static&gt; newCryptoKeyStore(KVSImplClass, opts) This is a factory method. It returns a new instance of the CryptoKeyStore. When the application needs to use a key store other than the default, it should create a new CryptoKeyStore and set it on the CryptoSuite. cryptosuite.setCryptoKeyStore(Client.newCryptoKeyStore(KVSImplClass, opts)) Parameters: Name Type Description KVSImplClass function Optional. The built-in key store saves private keys. The key store may be backed by different KeyValueStore implementations. If specified, the value of the argument must point to a module implementing the KeyValueStore interface. opts Object Implementation-specific option object used in the constructor Returns: a new instance of the CryptoKeystore Type CryptoKeyStore &lt;static&gt; newCryptoSuite(setting) This is a factory method. It returns a new instance of the CryptoSuite API implementation, based on the &quot;setting&quot; that is passed in, or if skipped, based on default values of the CryptoSetting properties. Parameters: Name Type Description setting CryptoSetting Optional Returns: a new instance of the CryptoSuite API implementation Type module:api.CryptoSuite &lt;static&gt; newDefaultKeyValueStore(options) Obtains an instance of the KeyValueStore class. By default it returns the built-in implementation, which is based on files (FileKeyValueStore). This can be overriden with a configuration setting key-value-store, the value of which is the full path of a CommonJS module for the alternative implementation. Parameters: Name Type Description options Object Specific to the implementation, for initializing the instance. For the built-in file-based implementation, this requires a single property path to the top-level folder for the store Returns: A Promise for a module:api.KeyValueStore instance of the KeyValueStore implementation Type Promise &lt;static&gt; normalizeX509(raw) Fixes a certificate string that may not be in the correct format. Make sure there's a start line with '-----BEGIN CERTIFICATE-----' and end line with '-----END CERTIFICATE-----', so as to be compliant with x509 parsers. Will remove or add required linefeeds and carriage returns. Parameters: Name Type Description raw string a string that contains a X509 certiicate Throws: An error indicating that the begining and end parts are not correct. Type Error &lt;static&gt; setConfigSetting(name, value) Adds a setting to override all settings that are part of the hierarchical configuration. The hierarchical configuration settings search order: see BaseClient.getConfigSetting Parameters: Name Type Description name String The name of a setting value Object The value of a setting &lt;static&gt; setLogger(logger) Configures a logger for the entire SDK to use and override the default logger. Unless this method is called, the SDK uses a default logger based on winston. When using the built-in winston based logger, use the configuration setting hfc-logging to pass in configurations in the following format: { 'error': 'error.log', // 'error' logs are printed to file 'error.log' relative of the current working dir for node.js 'debug': '/tmp/myapp/debug.log', // 'debug' and anything more critical ('info', 'warn', 'error') can also be an absolute path 'info': 'console' // 'console' is a keyword for logging to console } Parameters: Name Type Description logger Object a logger instance that defines the following methods: debug(), info(), warn(), error() with string interpolation methods like util.format. getCryptoSuite() Returns the CryptoSuite object used by this client instance Returns: Type module:api.CryptoSuite setCryptoSuite(cryptoSuite) Sets the client instance to use the CryptoSuite object for signing and hashing Creating and setting a CryptoSuite is optional because the client will construct an instance based on default configuration settings: crypto-hsm: use an implementation for Hardware Security Module (if set to true) or software-based key management (if set to false) crypto-keysize: security level, or key size, to use with the digital signature public key algorithm. Currently ECDSA is supported and the valid key sizes are 256 and 384 crypto-hash-algo: hashing algorithm key-value-store: some CryptoSuite implementation requires a key store to persist private keys. A CryptoKeyStore is provided for this purpose, which can be used on top of any implementation of the KeyValueStore interface, such as a file-based store or a database-based one. The specific implementation is determined by the value of this configuration setting. Parameters: Name Type Description cryptoSuite module:api.CryptoSuite the CryptoSuite object × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"BasePackager.html":{"id":"BasePackager.html","title":"Class: BasePackager","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: BasePackager BasePackager new BasePackager( [keep]) Constructor Parameters: Name Type Argument Description keep * &lt;optional&gt; Array of valid source file extensions Methods findMetadataDescriptors(filePath) Find the metadata descriptor files. Parameters: Name Type Description filePath The top-level directory containing the metadata descriptors. Only files with a &quot;.json&quot; extension will be included in the results. Returns: Type Promise findSource(filepath) Given an input 'filePath', recursively parse the filesystem for any files that fit the criteria for being valid chaincode source (ISREG + keep) Parameters: Name Type Description filepath generateTarGz(descriptors, dest) Creates an .tar.gz stream from the provided descriptor entries Parameters: Name Type Description descriptors dest Returns: Type Promise isMetadata(filePath) Predicate function for determining whether a given path should be considered a valid metadata descriptor based entirely on the file extension. Parameters: Name Type Description filePath The top-level directory containing the metadata descriptors. Returns: Returns true for valid metadata descriptors. Type boolean isSource(filePath) Predicate function for determining whether a given path should be considered valid source code, based entirely on the extension. It is assumed that other checks for file type (e.g. ISREG) have already been performed. Parameters: Name Type Description filePath Returns: Type boolean package(chaincodePath, metadataPath) All of the files in the directory of request.chaincodePath will be included in an archive file. Parameters: Name Type Description chaincodePath metadataPath packEntry(pack, desc) Given an {fqp, name} tuple, generate a tar entry complete with sensible header and populated contents read from the filesystem. Parameters: Name Type Description pack desc Returns: Type Promise × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"BlockDecoder.html":{"id":"BlockDecoder.html","title":"Class: BlockDecoder","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: BlockDecoder BlockDecoder Utility class to convert a protobuf encoded byte array of a Hyperledger Fabric block message into a pure Javascript object new BlockDecoder() Methods &lt;static&gt; decode(block_bytes) Constructs a JSON object containing all decoded values from the protobuf encoded `Block` bytes. Parameters: Name Type Description block_bytes Array.&lt;byte&gt; The encoded bytes of a Block protobuf message Returns: An object of the Block Type Block &lt;static&gt; decodeBlock(block_data) Constructs an object containing all decoded values from the protobuf encoded `Block` object Parameters: Name Type Description block_data Object an object that represents the protobuf common.Block Returns: An object of the fully decoded protobuf common.Block Type Block &lt;static&gt; decodeTransaction(processed_transaction_bytes) Constructs an object containing all decoded values from the protobuf encoded &quot;ProcessedTransaction&quot; bytes Parameters: Name Type Description processed_transaction_bytes Array.&lt;byte&gt; The encode bytes of a protobuf message &quot;ProcessedTransaction&quot; Returns: A fully decoded ProcessedTransaction object Type ProcessedTransaction × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"CertificateAuthority.html":{"id":"CertificateAuthority.html","title":"Class: CertificateAuthority","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: CertificateAuthority CertificateAuthority The CertificateAuthority class represents an Certificate Authority in the target blockchain network. new CertificateAuthority(name) Construct a CertificateAuthority object Parameters: Name Type Description name string The name of this Certificate Authority Methods getCaName() Gets the name of this CertificateAuthority to use in request Returns: The ca name of this CertificateAuthority Type string getConnectionOptions() Gets the connection options of this CertificateAuthority Returns: The connection options of this CertificateAuthority Type object getName() Gets the name of this CertificateAuthority Returns: The name of this CertificateAuthority Type string getRegistrar() Gets the registrar of this CertificateAuthority Returns: The registrar of this CertificateAuthority Type object getTlsCACerts() Gets the TLS CA Cert of this CertificateAuthority Returns: The TLS CA Cert PEM string of this CertificateAuthority Type string getUrl() Gets the url of this CertificateAuthority Returns: The url of this CertificateAuthority Type string toString() return a printable representation of this object × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"Channel.html":{"id":"Channel.html","title":"Class: Channel","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: Channel Channel In fabric v1.0, channels are the recommended way to isolate data and maintain privacy. A Channel object captures the settings needed to interact with a fabric backend in the context of a channel. These settings including the list of participating organizations, represented by instances of Membership Service Providers (MSP), the list of endorsing peers, and an orderer. A client application can use the Channel object to create new channels with the orderer, update an existing channel, send various channel-aware requests to the peers such as invoking chaincodes to process transactions or queries. A Channel object is also responsible for verifying endorsement signatures in transaction proposal responses. A channel object must be initialized after it has been configured with the list of peers and orderers. The initialization sends a get configuration block request to the primary orderer to retrieve the configuration settings for this channel. new Channel(name, clientContext) Returns a new instance of the class. This is a client-side-only call. To create a new channel in the fabric, call createChannel(). Parameters: Name Type Description name string Name to identify the channel. This value is used as the identifier of the channel when making channel-aware requests with the fabric, such as invoking chaincodes to endorse transactions. The naming of channels is enforced by the ordering service and must be unique within the fabric backend clientContext Client The client instance, which provides operational context such as the signing identity Methods addOrderer(orderer) Add the orderer object to the channel object, this is a client-side-only operation. An application may add more than one orderer object to the channel object, however the SDK only uses the first one in the list to send broadcast messages to the orderer backend. Parameters: Name Type Description orderer Orderer An instance of the Orderer class. addPeer(peer) Add the peer object to the channel object. A channel object can be optionally configured with a list of peer objects, which will be used when calling certain methods such as sendInstantiateProposal(), sendUpgradeProposal(), sendTransactionProposal. Parameters: Name Type Description peer Peer An instance of the Peer class that has been initialized with URL and other gRPC options such as TLS credentials and request timeout. close() Close the service connection off all assigned peers and orderers compareProposalResponseResults(The) Utility method to examine a set of proposals to check they contain the same endorsement result write sets. This will validate that the endorsing peers all agree on the result of the chaincode execution. Parameters: Name Type Description The Array.&lt;ProposalResponse&gt; proposal responses from all endorsing peers Returns: True when all proposals compare equally, false otherwise. Type boolean getChannelConfig(target) Asks the peer for the current (latest) configuration block for this channel. Parameters: Name Type Description target string | Peer Optional. The peer to be used to make the request. Returns: A Promise for a ConfigEnvelope object containing the configuration items. Type Promise getChannelConfigFromOrderer() Asks the orderer for the current (latest) configuration block for this channel. This is similar to getGenesisBlock(), except that instead of getting block number 0 it gets the latest block that contains the channel configuration, and only returns the decoded ConfigEnvelope. Returns: A Promise for a ConfigEnvelope object containing the configuration items. Type Promise getChannelEventHubsForOrg(org_name) Returns a list of ChannelEventHub based on the peers that are defined in this channel that are in the named orgainization of the currently loaded connection profile. If no connetion profile is loaded, an error will be thrown. When called with no organization name, the organization named in the currently active connection profile configuration's client section will be used. A peer with the &quot;eventSource&quot; role setting of true will be added to the list (a role will default to true if not defined). Parameters: Name Type Description org_name string Optional - The name of an organization Returns: An array of ChannelEventHub instances Type Array.&lt;ChannelEventHub&gt; getGenesisBlock(request) A channel's first block is called the &quot;genesis block&quot;. This block captures the initial channel configuration. For a peer node to join the channel, it must be provided the genesis block. This method must be called before calling joinChannel(). Parameters: Name Type Description request OrdererRequest Optional - A transaction ID object Returns: A Promise for an encoded protobuf &quot;Block&quot; Type Promise getMSPManager() Get the MSP Manager for this channel Returns: Type MSPManager getName() Get the channel name. Returns: The name of the channel. Type string getOrderers() Returns the orderers of this channel object. Returns: The list of orderers in the channel object Type Array.&lt;Orderer&gt; getOrganizations() Get organization identifiers from the MSP's for this channel Returns: Array of MSP identifiers representing the channel's participating organizations Type Array.&lt;string&gt; getPeers() Returns the list of peers of this channel object. Returns: The peer list on the channel. Type Array.&lt;Peer&gt; initialize(config) Initializes the channel object with the Membership Service Providers (MSPs). The channel's MSPs are critical in providing applications the ability to validate certificates and verify signatures in messages received from the fabric backend. For instance, after calling sendTransactionProposal(), the application can verify the signatures in the proposal response's endorsements to ensure they have not been tampered with. This method retrieves the configuration from the orderer if no &quot;config&quot; parameter is passed in. Optionally a configuration may be passed in to initialize this channel without making the call to the orderer. Parameters: Name Type Description config Array.&lt;byte&gt; Optional. An encoded (a.k.a un-decoded) byte array of the protobuf &quot;ConfigUpdate&quot; Returns: A Promise that will resolve when the action is complete Type Promise joinChannel(request, timeout) For a peer node to become part of a channel, it must be sent the genesis block, as explained here. This method sends a join channel proposal to one or more endorsing peers. Parameters: Name Type Description request JoinChannelRequest timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance(s) and the global timeout in the config settings. Returns: A Promise for an array of ProposalResponse from the target peers Type Promise newChannelEventHub() Returns an ChannelEventHub object. An event hub object encapsulates the properties of an event stream on a peer node, through which the peer publishes notifications of blocks being committed in the channel's ledger. Returns: The ChannnelEventHub instance Type ChannelEventHub queryBlock(blockNumber, target, useAdmin) Queries the ledger on the target peer for Block by block number. Parameters: Name Type Description blockNumber number The number of the Block in question. target Peer Optional. The peer to send this query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. Returns: A Promise for a Block at the blockNumber slot in the ledger, fully decoded into an object. Type Promise queryBlockByHash(block, target, useAdmin) Queries the ledger on the target peer for a Block by block hash. Parameters: Name Type Description block Array.&lt;byte&gt; hash of the Block in question. target Peer Optional. The peer to send the query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. Returns: A Promise for a Block matching the hash, fully decoded into an object. Type Promise queryBlockByTxID(tx_id, target, useAdmin) Queries the ledger on the target peer for a Block TransactionID. Parameters: Name Type Description tx_id string The TransactionID of the Block in question. target Peer Optional. The peer to send the query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. Returns: A Promise for a Block matching the tx_id, fully decoded into an object. Type Promise queryByChaincode(request) Sends a proposal to one or more endorsing peers that will be handled by the chaincode. In fabric v1.0, there is no difference in how the endorsing peers process a request to invoke a chaincode for transaction vs. to invoke a chaincode for query. All requests will be presented to the target chaincode's 'Invoke' method which must be implemented to understand from the arguments that this is a query request. The chaincode must also return results in the byte array format and the caller will have to be able to decode these results. Parameters: Name Type Description request ChaincodeQueryRequest Returns: A Promise for an array of byte array results returned from the chaincode on all Endorsing Peers Type Promise Example Get the list of query results returned by the chaincode channel.queryByChaincode(request) .then((response_payloads) =&gt; { for(let i = 0; i &lt; response_payloads.length; i++) { console.log(util.format('Query result from peer [%s]: %s', i, response_payloads[i].toString('utf8'))); } }); queryInfo(target, useAdmin) Queries for various useful information on the state of the Channel (height, known peers). Parameters: Name Type Description target Peer Optional. The peer that is the target for this query. If no target is passed, the query will use the first peer that was added to the channel object. useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. Returns: A Promise for a BlockchainInfo object with blockchain height, current block hash and previous block hash. Type Promise queryInstantiatedChaincodes(target, useAdmin) Queries the ledger on the target peer for instantiated chaincodes on this channel. Parameters: Name Type Description target Peer Optional. The peer to send this query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. An administrative identity must have been loaded by network configuration or by using the 'setAdminSigningIdentity' method. Returns: A Promise for a fully decoded ChaincodeQueryResponse object. Type Promise queryTransaction(tx_id, target, useAdmin) Queries the ledger on the target peer for Transaction by id. Parameters: Name Type Description tx_id string The id of the transaction target Peer Optional. The peer to send this query to. If no target is passed, the query is sent to the first peer that was added to the channel object. useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. Returns: A Promise for a fully decoded ProcessedTransaction object. Type Promise removeOrderer(orderer) Remove the first orderer object in the channel object's list of orderers whose endpoint url property matches the url of the orderer that is passed in. Parameters: Name Type Description orderer Orderer An instance of the Orderer class. removePeer(peer) Remove the first peer object in the channel object's list of peers whose endpoint url property matches the url of the peer that is passed in. Parameters: Name Type Description peer Peer An instance of the Peer class. sendInstantiateProposal(request, timeout) Sends a chaincode instantiate proposal to one or more endorsing peers. A chaincode must be instantiated on a channel-by-channel basis before it can be used. The chaincode must first be installed on the endorsing peers where this chaincode is expected to run, by calling client.installChaincode(). Instantiating a chaincode is a full transaction operation, meaning it must be first endorsed as a proposal, then the endorsements are sent to the orderer to be processed for ordering and validation. When the transaction finally gets committed to the channel's ledger on the peers, the chaincode is then considered activated and the peers are ready to take requests to process transactions. Parameters: Name Type Description request ChaincodeInstantiateUpgradeRequest timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Returns: A Promise for the ProposalResponseObject Type Promise sendTransaction(request) Send the proposal responses that contain the endorsements of a transaction proposal to the orderer for further processing. This is the 2nd phase of the transaction lifecycle in the fabric. The orderer will globally order the transactions in the context of this channel and deliver the resulting blocks to the committing peers for validation against the chaincode's endorsement policy. When the committering peers successfully validate the transactions, it will mark the transaction as valid inside the block. After all transactions in a block have been validated, and marked either as valid or invalid (with a reason code), the block will be appended (committed) to the channel's ledger on the peer. The caller of this method must use the proposal responses returned from the endorser along with the original proposal that was sent to the endorser. Both of these objects are contained in the ProposalResponseObject returned by calls to any of the following methods: installChaincode() sendInstantiateProposal() sendUpgradeProposal() sendTransactionProposal() Parameters: Name Type Description request TransactionRequest Returns: A Promise for a &quot;BroadcastResponse&quot; message returned by the orderer that contains a single &quot;status&quot; field for a standard HTTP response code. This will be an acknowledgement from the orderer of successfully submitted transaction. Type Promise sendTransactionProposal(request, timeout) Sends a transaction proposal to one or more endorsing peers. After a chaincode gets installed and instantiated, it's ready to take endorsement proposals and participating in transaction processing. A chaincode transaction starts with a proposal that gets sent to the endorsing peers, which executes the target chaincode and decides whether the proposal should be endorsed (if it executes successfully) or not (if the chaincode returns an error). Parameters: Name Type Description request ChaincodeInvokeRequest timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Returns: A Promise for the ProposalResponseObject Type Promise sendUpgradeProposal(request, timeout) Sends a chaincode upgrade proposal to one or more endorsing peers. Upgrading a chaincode involves steps similar to instantiating a chaincode. The new chaincode must first be installed on the endorsing peers where this chaincode is expected to run. Similar to instantiating a chaincode, upgrading chaincodes is also a full transaction operation. Parameters: Name Type Description request ChaincodeInstantiateUpgradeRequest timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Returns: A Promise for the ProposalResponseObject Type Promise setMSPManager(msp_manager) Set the MSP Manager for this channel. This utility method will not normally be use as the initialize() method will read this channel's current configuration and reset MSPManager with the MSP's found in the channel configuration. Parameters: Name Type Description msp_manager MSPManager The msp manager for this channel toString() return a printable representation of this channel object verifyProposalResponse(proposal_response) Utility method to verify a single proposal response. It checks the following aspects: The endorser's identity belongs to a legitimate MSP of the channel and can be successfully deserialized The endorsement signature can be successfully verified with the endorser's identity certificate This method requires that the initialize method of this channel object has been called to load this channel's MSPs. The MSPs will have the trusted root certificates for this channel. Parameters: Name Type Description proposal_response ProposalResponse The endorsement response from the peer, includes the endorser certificate and signature over the proposal + endorsement result + endorser certificate. Returns: A boolean value of true when both the identity and the signature are valid, false otherwise. Type boolean × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"ChannelEventHub.html":{"id":"ChannelEventHub.html","title":"Class: ChannelEventHub","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: ChannelEventHub ChannelEventHub Transaction processing in fabric v1.1 is a long operation spanning multiple components (application, endorsing peer, orderer, committing peer) and takes a relatively lengthy period of time (think seconds instead of milliseconds) to complete. As a result the applications must design their handling of the transaction lifecyle in an asynchrous fashion. After the transaction proposal has been successfully endorsed, and before the transaction message has been successfully broadcast to the orderer, the application should register a listener to be notified of the event when the transaction achieves finality, which is when the block containing the transaction gets added to the peer's ledger/blockchain. Fabric committing peers provides an event stream to publish blocks to registered listeners. A Block gets published whenever the committing peer adds a validated block to the ledger. There are three ways to register a listener to get notified: register a &quot;block listener&quot; to get called for every block event. The listener will be passed a fully decoded Block object. See registerBlockEvent register a &quot;transaction listener&quot; to get called when the specific transaction by id is committed (discovered inside a published block). The listener will be passed the transaction id, transaction status and block number. See registerTxEvent register a &quot;chaincode event listener&quot; to get called when a specific chaincode event has arrived. The listener will be passed the ChaincodeEvent, block number, transaction id, and transaction status. See registerChaincodeEvent The events are ephemeral, such that if a registered listener crashed when the event is published, the listener will miss the event. There are several techniques to compensate for missed events due to client crashes: register block event listeners and record the block numbers received, such that when the next block arrives and its number is not the next in sequence, then the application knows exactly which block events have been missed. It can then use queryBlock to get those missed blocks from the target peer or register for events using the startBlock option to resume or replay the events. You may also include an endBlock number if you wish to stop listening. use a message queue to catch all the block events. With many robust message queue implementations available today, you will be guaranteed to not miss an event. A fabric event listener can be written in any programming language. The following implementations can be used as reference to write the necessary glue code between the fabric event stream and a message queue: new ChannelEventHub(channel, peer) Constructs a ChannelEventHub object Parameters: Name Type Description channel Channel An instance of the Channel class were this event hub will receive blocks from peer Peer An instance of the Peer class this event hub connects to. Example var eh = channel.newChannelEventHub(peer); // register the listeners before calling &quot;connect()&quot; so there // is an error callback ready to process an error in case the // connect() call fails eh.registerTxEvent( transactionId, (tx, code) =&gt; { eh.unregisterTxEvent(transactionId); console.log(util.format('Transaction %s has completed', transactionId)); }, (err) =&gt; { eh.unregisterTxEvent(transactionId); console.log(util.format('Error %s! Transaction listener for %s has been ' + 'deregistered with %s', transactionId, err, eh.getPeerAddr())); } ); eh.connect(); Methods checkConnection(force_reconnect) Returns the connection state. and will attempt a restart when forced Parameters: Name Type Description force_reconnect boolean attempt to reconnect if the state is not in the 'READY' state connect(full_block) Establishes a connection with the peer event source. The peer address must be set by calling the setPeerAddr() method before calling this method. The connection will be established asynchronously. If the connection fails to get established, the application will be notified via the error callbacks from the registerXXXEvent() methods. It is recommended that an application always registers at least one event listener with an error callback, by calling any one of the registerBlockEvent, registerTxEvent or registerChaincodeEvent methods, before calling connect(). Parameters: Name Type Description full_block boolean to indicated that the connection with the peer will be sending full blocks or filtered blocks to this ChannelEventHub. The default will be to establish a connection using filtered blocks. Filtered blocks have the required information to provided transaction status and chaincode events. When using the non filtered blocks the user will be required to have access to establish the connection to receive full blocks. Registering a block listener on a filtered block connection may not provide suficient information. disconnect() Disconnects the event hub from the peer event source. Will close all event listeners and send an Error object with the message &quot;ChannelEventHub has been shutdown&quot; to all listeners that provided an &quot;onError&quot; callback. getPeerAddr() Return the peer url of this event hub object isconnected() Is the event hub connected to the event source? Returns: True if connected to the event source, false otherwise Type boolean registerBlockEvent(onEvent, onError, options) Register a listener to receive all block events from all the channels that the target peer is part of. The listener's &quot;onEvent&quot; callback gets called on the arrival of every block. If the target peer is expected to participate in more than one channel, then care must be taken in the listener's implementation to differentiate blocks from different channels. See the example below on how to accomplish that. An error may occur in the connection establishment which runs asynchronously. The best practice would be to provide an &quot;onError&quot; callback to be notified when this ChannelEventHub has an issue. Parameters: Name Type Description onEvent function Callback function that takes a single parameter of a Block object onError function Optional callback function to be notified when this event hub is shutdown. The shutdown may be caused by a network error or by a call to the &quot;disconnect()&quot; method or a connection error. options RegistrationOpts options Returns: This is the block registration number that must be sed to unregister (see unregisterBlockEvent) Type int Example Find out the channel Id of the arriving block eh.registerBlockEvent( (block) =&gt; { let first_tx = block.data.data[0]; // get the first transaction let header = first_tx.payload.header; // the &quot;header&quot; object contains metadata of the transaction let channel_id = header.channel_header.channel_id; if (&quot;mychannel&quot; !== channel_id) return; // do useful processing of the block }, (err) =&gt; { console.log('Oh snap!'); } ); registerChaincodeEvent(ccid, eventname, onEvent, onError, options) Register a listener to receive chaincode events. An error may occur in the connection establishment which runs asynchronously. The best practice would be to provide an &quot;onError&quot; callback to be notified when this ChannelEventHub has an issue. Parameters: Name Type Description ccid string Id of the chaincode of interest eventname string The exact name of the chaincode event (must match the name given to the target chaincode's call to stub.SetEvent(name, payload)), or a regular expression string to match more than one event by this chaincode. onEvent function callback function for matched events. It gets passed four parameters, a ChaincodeEvent object, the block number this transaction was committed to the ledger, the transaction ID, and a string representing the status of the transaction. onError function Optional callback function to be notified when this event hub is shutdown. The shutdown may be caused by a network error or by a call to the &quot;disconnect()&quot; method or a connection error. options RegistrationOpts options Returns: An object that should be treated as an opaque handle used to unregister (see unregisterChaincodeEvent) Type Object registerTxEvent(txid, onEvent, onError, options) Register a callback function to receive a notification when the transaction by the given id has been committed into a block. An error may occur in the connection establishment which runs asynchronously. The best practice would be to provide an &quot;onError&quot; callback to be notified when this ChannelEventHub has an issue. Parameters: Name Type Description txid string Transaction id string onEvent function Callback function that takes a parameter of transaction ID, a string parameter indicating the transaction status, and the block number this transaction was committed to the ledger onError function Optional callback function to be notified when this event hub is shutdown. The shutdown may be caused by a network error or by a call to the &quot;disconnect()&quot; method or a connection error. options RegistrationOpts options Returns: The transaction ID that was used to register this event listener, will the same as the txid parameter and must be used to unregister this event listener. Type string unregisterBlockEvent(block_registration_number, throwError) Unregister the block event listener using the block registration number that is returned by the call to the registerBlockEvent() method. Parameters: Name Type Description block_registration_number int The block registration number that was returned during registration. throwError boolean Optional - throw an error if the block registration does not exist, default is to not throw an error unregisterChaincodeEvent(listener_handle, throwError) Unregister the chaincode event listener represented by the listener_handle object returned by the registerChaincodeEvent() method Parameters: Name Type Description listener_handle Object The handle object returned from the call to registerChaincodeEvent. throwError boolean Optional - throw an error if the block registration does not exist, default is to not throw an error unregisterTxEvent(txid, throwError) Unregister transaction event listener for the transaction id. Parameters: Name Type Description txid string The transaction id throwError boolean Optional - throw an error if the block registration does not exist, default is to not throw an error × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: Client Client A client instance provides the main API surface to interact with a network of peers and orderers. An application using the SDK may need to interact with multiple networks, each through a separate instance of the Client. An important aspect of the current design of the Client class is that it is stateful. An instance must be configured with a userContext before it can be used to talk to the fabric backend. A userContext is an instance of the User class, which encapsulates the ability to sign requests. If the SDK is used in a multi-user environment, there are two recommended techniques to manage the authenticated users and instances of clients. Use a dedicated client instance per authenticated user. Create a new instance for each authenticated user. You can enroll each authenticated user separately so that each user gets its own signing identity. Use a shared client instance and a common signing identity among authenticated users. It is important to understand that switching userContexts with the same client instance is considered an anti-pattern. This is the direct result of the stateful design. A JIRA work item has been opened to discuss adding support for stateless usage of the SDK: FAB-4563 The client also supports persistence via a stateStore. A state store is a simple storage plugin that implements the module:api.KeyValueStore interface, which helps the SDK save critical information to be used across server restarts/crashes. Out of the box, the SDK saves the signing identities (instances of the User class) in the state store. new Client() Extends BaseClient Methods &lt;static&gt; loadFromConfig(config) Load a network configuration object or load a JSON file and return a Client object. Parameters: Name Type Description config object | string This may be the config object or a path to the configuration file Returns: An instance of this class initialized with the network end points. Type Client addTlsClientCertAndKey(opts) Utility method to add the mutual tls client material to a set of options Parameters: Name Type Description opts object The options object holding the connection settings that will be updated with the mutual TLS clientCert and clientKey. createChannel(request) Calls the orderer to start building the new channel. A channel typically has more than one participating organizations. To create a new channel, one of the participating organizations should call this method to submit the creation request to the orderer service. Once the channel is successfully created by the orderer, the next step is to have each organization's peer nodes join the channel, by sending the channel configuration to each of the peer nodes. The step is accomplished by calling the joinChannel() method. Parameters: Name Type Description request ChannelRequest The request object. Returns: Promise for a result object with status on the acceptance of the create request by the orderer. Note that this is not the confirmation of successful creation of the channel. The client application must poll the orderer to discover whether the channel has been created completely or not. Type Promise createUser(opts) Returns a User object with signing identities based on the private key and the corresponding x509 certificate. This allows applications to use pre-existing crypto materials (private keys and certificates) to construct user objects with signing capabilities, as an alternative to dynamically enrolling users with fabric-ca Note that upon successful creation of the new user object, it is set to the client instance as the current userContext. Parameters: Name Type Description opts UserOpts Essential information about the user Returns: Promise for the user object. Type Promise extractChannelConfig(config_envelope) Extracts the protobuf 'ConfigUpdate' object out of the 'ConfigEnvelope' object that is produced by the configtxgen tool. The returned object may then be signed using the signChannelConfig() method of this class. Once the all signatures have been collected, the 'ConfigUpdate' object and the signatures may be used on the createChannel() or updateChannel() calls. Parameters: Name Type Description config_envelope Array.&lt;byte&gt; The encoded bytes of the ConfigEnvelope protobuf Returns: The encoded bytes of the ConfigUpdate protobuf, ready to be signed Type Array.&lt;byte&gt; getCertificateAuthority(name) Returns a CertificateAuthority implementation as defined by the settings in the currently loaded network configuration and the client configuration. A network configuration must be loaded for this get method to return a Certificate Authority. A crypto suite must be assigned to this client instance. Running the 'initCredentialStores' method will build the stores and create a crypto suite as defined in the network configuration. Parameters: Name Type Description name string Optional - the name of the Certificate Authority defined in the loaded connection profile. Returns: Type CertificateAuthority getChannel(name, throwError) Get a Channel instance from the client instance. This is a memory-only lookup. If the loaded network configuration has a channel by the 'name', a new channel instance will be created and populated with Orderer objects and Peer objects as defined in the network configuration. Parameters: Name Type Description name string Optional. The name of the channel. When omitted the first channel defined in the loaded network configuration will be returned throwError boolean Indicates if this method will throw an error if the channel is not found. Default is true. Returns: The channel instance Type Channel getClientConfig() Returns the &quot;client&quot; section of the network configuration. Returns: The client section from the configuration Type object getCryptoSuite() Returns the CryptoSuite object used by this client instance Inherited From: BaseClient#getCryptoSuite Returns: Type module:api.CryptoSuite getEventHub(peer_name) Returns and EventHub object based on the event hub address as defined in the currently loaded network configuration for the peer by the name parameter. The named peer must have the &quot;eventUrl&quot; setting or a null will be returned. Parameters: Name Type Description peer_name string The name of the peer that has an event hub defined Returns: The EventHub instance that has had the event hub address assigned Type EventHub getEventHubsForOrg(org_name) Returns a list of EventHub for the named organization as defined in the currently loaded network configuration. If no organization is provided then the organization named in the currently active network configuration's client section will be used. The list will be based on the peers in the organization that have the &quot;eventUrl&quot; setting. Parameters: Name Type Description org_name string Optional - The name of an organization Returns: An array of EventHub instances that are defined for this organization Type Array.&lt;EventHub&gt; getMspid() Returns the mspid of the currently loaded client's organization as defined in the network configuration. Returns: the mspid of the organization defined in the client section of the loaded network configuration Type string getPeersForOrg(org_name) Returns a list of Peer for the named organization as defined in the currently loaded network configuration. If no organization is provided then the organization named in the currently active network configuration's client section will be used. Parameters: Name Type Description org_name string Optional - The name of an organization Returns: An array of Peer instances that are defined for this organization Type Array.&lt;Peer&gt; getStateStore() A convenience method for obtaining the state store object in use by this client. Returns: The KeyValueStore implementation object set on this Client, or null if one has not been set. Type module:api.KeyValueStore getUserContext(name, checkPersistence) Returns the user by the given name. This can be a synchronous call or asynchronous call, depending on whether &quot;checkPersistent&quot; is truthy or not. If truthy, the method is asynchronous and returns a Promise, otherwise it's synchronous. As explained above, the client instance can have an optional state store. The SDK saves enrolled users in the storage which can be accessed by authorized users of the application (authentication is done by the application outside of the SDK). This function attempts to load the user by name from the local storage (via the KeyValueStore interface). The loaded user object must represent an enrolled user with a valid enrollment certificate signed by a trusted CA (such as the CA server). Parameters: Name Type Description name String Optional. If not specified, will only return the current in-memory user context object, or null if none has been set. If &quot;name&quot; is specified, will also attempt to load it from the state store if search in memory failed. checkPersistence boolean Optional. If specified and truthy, the method returns a Promise and will attempt to check the state store for the requested user by the &quot;name&quot;. If not specified or falsey, the method is synchronous and returns the requested user from memory Returns: Promise for the user object corresponding to the name, or null if the user does not exist or if the state store has not been set. If &quot;checkPersistence&quot; is not specified or false, then the user object is returned synchronously. Type Promise | User initCredentialStores() Sets the state and crypto suite for use by this client. This requires that a network config has been loaded. Will use the settings from the network configuration along with the system configuration to build instances of the stores and assign them to this client and the crypto suites if needed. Returns: - A promise to build a key value store and crypto store. Type Promise installChaincode(request, timeout) In fabric v1.0, a chaincode must be installed and instantiated before it can be called to process transactions. Chaincode installation is simply uploading the chaincode source and dependencies to the peers. This operation is &quot;channel-agnostic&quot; and is performed on a peer-by-peer basis. Only the peer organization's ADMIN identities are allowed to perform this operation. Parameters: Name Type Description request ChaincodeInstallRequest The request object timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Returns: A Promise for a ProposalResponseObject Type Promise isDevMode() Determine if the fabric backend is started in development mode. In development mode, the endorsing peers will not attempt to spin up a docker instance to run the target chaincode requested by a transaction proposal, but instead redirect the invocation requests to the chaincode process that has registered itself with the endorsing peer. This makes it easier to test changes to the chaincode during chaincode development. The client instance can be set to dev mode to reflect the backend's development mode. This will cause the SDK to make adjustments in certain behaviors such as not sending the chaincode package to the peers during chaincode install. loadFromConfig(config) Load a network configuration object or load a JSON file and update this client with any values in the config. Parameters: Name Type Description config object | string This may be the config object or a path to the configuration file loadUserFromStateStore(name) Restore the state of the User by the given name from the key value store (if found). If not found, return null. Parameters: Name Type Description name string Name of the user Returns: A Promise for a {User} object upon successful restore, or if the user by the name does not exist in the state store, returns null without rejecting the promise Type Promise newChannel(name) Returns a Channel instance with the given name. This represents a channel and its associated ledger. Parameters: Name Type Description name string The name of the channel. Recommend using namespaces to avoid collision. Returns: The uninitialized channel instance. Type Channel newEventHub() Returns an EventHub object. An event hub object encapsulates the properties of an event stream on a peer node, through which the peer publishes notifications of blocks being committed in the channel's ledger. Returns: The EventHub instance Type EventHub newOrderer(url, opts) Returns an Orderer object with the given url and opts. An orderer object encapsulates the properties of an orderer node and the interactions with it via the grpc stream API. Orderer objects are used by the Client objects to broadcast requests for creating and updating channels. They are used by the Channel objects to broadcast requests for ordering transactions. Parameters: Name Type Description url string The URL with format of &quot;grpc(s)://host:port&quot;. opts ConnectionOpts The options for the connection to the orderer. Returns: The Orderer instance. Type Orderer newPeer(url, opts) Returns a Peer object with the given url and opts. A peer object encapsulates the properties of an endorsing peer and the interactions with it via the grpc service API. Peer objects are used by the Client objects to send channel-agnostic requests such as installing chaincode, querying peers for installed chaincodes, etc. They are also used by the Channel objects to send channel-aware requests such as instantiating chaincodes, and invoking transactions. Parameters: Name Type Description url string The URL with format of &quot;grpc(s)://host:port&quot;. opts ConnectionOpts The options for the connection to the peer. Returns: The Peer instance. Type Peer newTransactionID(If) Returns a new TransactionID object. Fabric transaction ids are constructed as a hash of a nonce concatenated with the signing identity's serialized bytes. The TransactionID object keeps the nonce and the resulting id string bundled together as a coherent pair. This method requires the client instance to have been assigned a userContext. Parameters: Name Type Description If boolean this transactionID should be built based on the admin credentials Default is a non admin TransactionID Returns: An object that contains a transaction id based on the client's userContext and a randomly generated nonce value. Type TransactionID queryChannels(peer, useAdmin) Queries the target peer for the names of all the channels that a peer has joined. Parameters: Name Type Description peer Peer The target peer to send the query useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. An administrative identity must have been loaded by network configuration or by using the 'setAdminSigningIdentity' method. Returns: A promise to return a ChannelQueryResponse Type Promise queryInstalledChaincodes(peer, useAdmin) Queries the installed chaincodes on a peer. Parameters: Name Type Description peer Peer The target peer useAdmin boolean Optional. Indicates that the admin credentials should be used in making this call to the peer. An administrative identity must have been loaded by network configuration or by using the 'setAdminSigningIdentity' method. Returns: Promise for a ChaincodeQueryResponse object Type Promise saveUserToStateStore() Persist the current userContext to the key value store. Returns: A Promise for the userContext object upon successful persistence Type Promise setAdminSigningIdentity(private_key, certificate, mspid) Set the admin signing identity object. This method will only assign a signing identity for use by this client instance and will not persist the identity. Parameters: Name Type Description private_key string the private key PEM string certificate string the PEM-encoded string of certificate mspid string The Member Service Provider id for the local signing identity setCryptoSuite(cryptoSuite) Sets the client instance to use the CryptoSuite object for signing and hashing Creating and setting a CryptoSuite is optional because the client will construct an instance based on default configuration settings: crypto-hsm: use an implementation for Hardware Security Module (if set to true) or software-based key management (if set to false) crypto-keysize: security level, or key size, to use with the digital signature public key algorithm. Currently ECDSA is supported and the valid key sizes are 256 and 384 crypto-hash-algo: hashing algorithm key-value-store: some CryptoSuite implementation requires a key store to persist private keys. A CryptoKeyStore is provided for this purpose, which can be used on top of any implementation of the KeyValueStore interface, such as a file-based store or a database-based one. The specific implementation is determined by the value of this configuration setting. Parameters: Name Type Description cryptoSuite module:api.CryptoSuite the CryptoSuite object Inherited From: BaseClient#setCryptoSuite setDevMode(devMode) Set dev mode to true or false to reflect the mode of the fabric backend. See Client#isDevMode for details. Parameters: Name Type Description devMode boolean setStateStore(keyValueStore) Set an optional state store to persist application states. The state store must implement the module:api.KeyValueStore interface. The SDK supports persisting the User objects so that the heavy-weight objects such as the certificate and private keys do not have to be passed in repeatedly. Out of the box the SDK provides a file-based implementation, and a CouchDB-based implementation, which also supports Cloudant. Applications can provide alternative implementations. Parameters: Name Type Description keyValueStore module:api.KeyValueStore Instance of a KeyValueStore implementation setTlsClientCertAndKey(clientCert, clientKey) Sets the mutual TLS client side certificate and key necessary to build network endpoints when working with a network configuration (connection profile). This must be called before a peer, orderer, or channel eventhub is needed. Parameters: Name Type Description clientCert string The pem encoded client certificate. clientKey Array.&lt;byte&gt; The client key. setUserContext(user, skipPersistence) Sets an instance of the User class as the security context of this client instance. This user’s signing identity (the private key and its corresponding certificate), will be used to sign all requests with the fabric backend. Upon setting the user context, the SDK saves the object in a persistence cache if the “state store” has been set on the Client instance. If no state store has been set, this cache will not be established and the application is responsible for setting the user context again if the application crashes and is recovered. Parameters: Name Type Description user User | UserNamePasswordObject An instance of the User class encapsulating the authenticated user’s signing materials (private key and enrollment certificate). The parameter may also be a UserNamePasswordObject that contains the username and optionaly the password. A network configuration must has been loaded to use the UserNamePasswordObject which will also create the user context and set it on this client instance. The created user context will be based on the current network configuration( i.e. the current organization's CA, current persistence stores). skipPersistence boolean Whether to skip saving the user object into persistence. Default is false and the method will attempt to save the user object to the state store. When using a network configuration and UserNamePasswordObject, the user object will always be stored to the persistence store. Returns: Promise of the 'user' object upon successful persistence of the user to the state store Type Promise signChannelConfig(config) Channel configuration updates can be sent to the orderers to be processed. The orderer enforces the Channel creation or update policies such that the updates will be made only when enough signatures from participating organizations are discovered in the request. Typically channel creation or update requests must be signed by participating organizations' ADMIN principals, although this policy can be customized when the consortium is defined. This method uses the client instance's current signing identity to sign over the configuration bytes passed in, and returns the signature that is ready to be included in the configuration update protobuf message to send to the orderer. Parameters: Name Type Description config Array.&lt;byte&gt; The Configuration Update in byte form Returns: - The signature of the current user on the config bytes Type ConfigSignature updateChannel(request) Calls the orderer to update an existing channel. After the channel updates are successfully processed by the orderer, the orderer cuts a new block containing the new channel configuration and delivers it to all the participating peers in the channel. Parameters: Name Type Description request ChannelRequest The request object. Returns: Promise for a result object with status on the acceptance of the update request by the orderer. A channel update is finally completed when the new channel configuration block created by the orderer has been committed to the channel's peers. To be notified of the successful update of the channel, an application should use the EventHub to connect to the peers and register a block listener. Type Promise × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"CouchDBKeyValueStore.html":{"id":"CouchDBKeyValueStore.html","title":"Class: CouchDBKeyValueStore","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: CouchDBKeyValueStore CouchDBKeyValueStore This is a sample database implementation of the KeyValueStore API. It uses a local or remote CouchDB database instance to store the keys. new CouchDBKeyValueStore(options) constructor Parameters: Name Type Description options CouchDBOpts Settings used to connect to a CouchDB instance Extends module:api.KeyValueStore Methods getValue(name) Get the value associated with name. Parameters: Name Type Description name string Name of the key Inherited From: module:api.KeyValueStore#getValue Overrides: module:api.KeyValueStore#getValue Returns: Promise for the value corresponding to the key. If the value does not exist in the store, returns null without rejecting the promise Type Promise setValue(name, value) Set the value associated with name. Parameters: Name Type Description name string Name of the key to save value string The Value to save Inherited From: module:api.KeyValueStore#setValue Overrides: module:api.KeyValueStore#setValue Returns: Promise for the 'value' object upon successful write operation Type Promise × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"CryptoKeyStore.html":{"id":"CryptoKeyStore.html","title":"Class: CryptoKeyStore","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: CryptoKeyStore CryptoKeyStore new CryptoKeyStore(KVSImplClass, opts) A CryptoKeyStore uses an underlying instance of module:api.KeyValueStore implementation to persist crypto keys. Parameters: Name Type Description KVSImplClass function Optional. The built-in key store saves private keys. The key store may be backed by different KeyValueStore implementations. If specified, the value of the argument must point to a module implementing the KeyValueStore interface. opts Object Implementation-specific option object used in the constructor × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"CryptoSuite_ECDSA_AES.html":{"id":"CryptoSuite_ECDSA_AES.html","title":"Class: CryptoSuite_ECDSA_AES","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: CryptoSuite_ECDSA_AES CryptoSuite_ECDSA_AES The module:api.CryptoSuite implementation for ECDSA, and AES algorithms using software key generation. This class implements a software-based key generation (as opposed to Hardware Security Module based key management) new CryptoSuite_ECDSA_AES(keySize, hash) constructor Parameters: Name Type Description keySize number Key size for the ECDSA algorithm, can only be 256 or 384 hash string Optional. Hash algorithm, supported values are &quot;SHA2&quot; and &quot;SHA3&quot; Extends module:api.CryptoSuite Methods decrypt() This is an implementation of module:api.CryptoSuite#decrypt To be implemented. Overrides: module:api.CryptoSuite#decrypt deriveKey() This is an implementation of module:api.CryptoSuite#deriveKey To be implemented Overrides: module:api.CryptoSuite#deriveKey encrypt() This is an implementation of module:api.CryptoSuite#encrypt To be implemented. Overrides: module:api.CryptoSuite#encrypt generateKey(opts) Generate a key using the options in opts. If the opts.ephemeral parameter is false, the method, in addition to returning the imported Key instance, also persists the generated key in the key store as PEM files that can be retrieved using the getKey() method Parameters: Name Type Description opts KeyOpts Optional Inherited From: module:api.CryptoSuite#generateKey Overrides: module:api.CryptoSuite#generateKey Returns: Promise for an instance of the Key class Type module:api.Key getKey(ski) Returns the Key this implementation associates to the Subject Key Identifier ski. Parameters: Name Type Description ski string Subject Key Identifier specific to a Crypto Suite implementation, as the unique index to represent the key Inherited From: module:api.CryptoSuite#getKey Overrides: module:api.CryptoSuite#getKey Returns: Promise of an instance of the Key class corresponding to the ski Type module:api.Key hash() This is an implementation of module:api.CryptoSuite#hash The opts argument is not supported. Overrides: module:api.CryptoSuite#hash importKey() This is an implementation of module:api.CryptoSuite#importKey To be implemented Overrides: module:api.CryptoSuite#importKey setCryptoKeyStore(cryptoKeyStore) Set the cryptoKeyStore. When the application needs to use a key store other than the default, it should use the Client newCryptoKeyStore to create an instance and use this function to set the instance on the CryptoSuite. Parameters: Name Type Description cryptoKeyStore CryptoKeyStore The cryptoKeyStore. sign() This is an implementation of module:api.CryptoSuite#sign Signs digest using key k. Overrides: module:api.CryptoSuite#sign verify(key, signature, digest) Verifies signature against key and digest Parameters: Name Type Description key module:api.Key Signing verification key (public key) signature Array.&lt;byte&gt; The signature to verify digest Array.&lt;byte&gt; The digest that the signature was created for Inherited From: module:api.CryptoSuite#verify Overrides: module:api.CryptoSuite#verify Returns: true if the signature verifies successfully Type boolean × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"CryptoSuite_PKCS11.html":{"id":"CryptoSuite_PKCS11.html","title":"Class: CryptoSuite_PKCS11","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: CryptoSuite_PKCS11 CryptoSuite_PKCS11 PKCS#11-compliant implementation to support Hardware Security Modules. new CryptoSuite_PKCS11(keySize, hash, opts) Parameters: Name Type Description keySize number Length of key (in bytes), a.k.a &quot;security level&quot; hash string Optional. Hash algorithm, supported values are &quot;SHA2&quot; and &quot;SHA3&quot; opts Object Options are of the form { lib: string, // the library package to support this implementation slot: number, // the hardware slot number pin: string, // the user's PIN usertype: number, // the user type readwrite: boolean // true if the session is read/write or false if read-only } If 'lib' is not specified or null, its value will be taken from the CRYPTO_PKCS11_LIB env var, and if the env var is not set, its value will be taken from the crypto-pkcs11-lib key in the configuration file. If 'slot' is not specified or null, its value will be taken from the CRYPTO_PKCS11_SLOT env var, and if the env var is not set, its value will be taken from the crypto-pkcs11-slot key in the configuration file. If 'pin' is not specified or null, its value will be taken from the CRYPTO_PKCS11_PIN env var, and if the env var is not set, its value will be taken from the crypto-pkcs11-pin key in the configuration file. If 'usertype' is not specified or null, its value will be taken from the CRYPTO_PKCS11_USERTYPE env var, if the env var is not set, its value will be taken from the crypto-pkcs11-usertype key in the configuration file, if the config value is not set, its value will default to 1. The value will not be validated, assumes the C_Login will validate. --- from http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os.html 0 CKU_SO 0UL 1 CKU_USER 1UL 2 CKU_CONTEXT_SPECIFIC 2UL 4294967295 max allowed 0xFFFFFFFFUL If 'readwrite' is not specified or null, its value will be taken from the CRYPTO_PKCS11_READWRITE env var, if the env var is not set, its value will be taken from the crypto-pkcs11-readwrite key in the configuration file, if the config value is not set, its value will default to true. Extends module:api.CryptoSuite Methods decrypt() This is an implementation of module:api.CryptoSuite#decrypt Decrypts cipherText using key. The opts argument is not supported yet. Overrides: module:api.CryptoSuite#decrypt deriveKey() This is an implementation of module:api.CryptoSuite#deriveKey Overrides: module:api.CryptoSuite#deriveKey encrypt() This is an implementation of module:api.CryptoSuite#encrypt Encrypts plainText using key. The opts argument is not supported. Overrides: module:api.CryptoSuite#encrypt generateKey() This is an implementation of module:api.CryptoSuite#generateKey Returns an instance of module.api.Key representing the private key, which also encapsulates the public key. By default the generated key (keypar) is (are) ephemeral unless opts.ephemeral is set to false, in which case the key (keypair) will be saved across PKCS11 sessions by the HSM hardware. Overrides: module:api.CryptoSuite#generateKey Returns: Promise of an instance of module:PKCS11_ECDSA_KEY containing the private key and the public key. Type module:api.Key getKey() This is an implementation of module:api.CryptoSuite#getKey Returns the key this CSP associates to the Subject Key Identifier ski. Overrides: module:api.CryptoSuite#getKey hash() This is an implementation of module:api.CryptoSuite#hash The opts argument is not supported yet. Overrides: module:api.CryptoSuite#hash importKey() This is an implementation of module:api.CryptoSuite#importKey Overrides: module:api.CryptoSuite#importKey sign() This is an implementation of module:api.CryptoSuite#sign Signs digest using key k. Overrides: module:api.CryptoSuite#sign verify() This is an implementation of module:api.CryptoSuite#verify Verifies signature against key k and digest Overrides: module:api.CryptoSuite#verify × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"ECDSA_KEY.html":{"id":"ECDSA_KEY.html","title":"Class: ECDSA_KEY","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: ECDSA_KEY ECDSA_KEY new ECDSA_KEY() This module implements the module:api.Key interface, for ECDSA. Extends module:api.Key Methods getPublicKey() Returns the corresponding public key if this key is an asymmetric private key. If this key is already public, returns this key itself. Inherited From: module:api.Key#getPublicKey Returns: the corresponding public key if this key is an asymmetric private key. If this key is already public, returns this key itself. Type module:api.Key getSKI() Returns the subject key identifier of this key Inherited From: module:api.Key#getSKI Returns: The subject key identifier of this key as a hexidecial encoded string Type string isPrivate() Returns true if this key is an asymmetric private key, false otherwise. Inherited From: module:api.Key#isPrivate Returns: if this key is an asymmetric private key Type boolean isSymmetric() Returns true if this key is a symmetric key, false is this key is asymmetric Inherited From: module:api.Key#isSymmetric Returns: if this key is a symmetric key Type boolean toBytes() Converts this key to its PEM representation, if this operation is allowed. Inherited From: module:api.Key#toBytes Returns: the PEM string representation of the key Type string × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"EndorsementPolicy.html":{"id":"EndorsementPolicy.html","title":"Class: EndorsementPolicy","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: EndorsementPolicy EndorsementPolicy Governs the constructions of endorsement policies to be passed into the calls to instantiate chaincodes new EndorsementPolicy() Methods &lt;static&gt; buildPolicy(msps, policy) Constructs an endorsement policy envelope. If the optional &quot;policy&quot; object is not present, a default policy of &quot;a signature by any member from any of the organizations corresponding to the array of member service providers&quot; is returned. Parameters: Name Type Description msps Array.&lt;MSP&gt; Array of Member Service Provider objects representing the participants of the endorsement policy to be constructed policy Policy The policy specification. It has two high-level properties: identities and policy. see the type definition of Policy for details. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"EventHub.html":{"id":"EventHub.html","title":"Class: EventHub","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: EventHub EventHub Transaction processing in fabric v1.0 is a long operation spanning multiple components (application, endorsing peer, orderer, committing peer) and takes a relatively lengthy period of time (think seconds instead of milliseconds) to complete. As a result the applications must design their handling of the transaction lifecyle in an asynchrous fashion. After the transaction proposal has been successfully endorsed, and before the transaction message has been successfully broadcast to the orderer, the application should register a listener to be notified of the event when the transaction achieves finality, which is when the block containing the transaction gets added to the peer's ledger/blockchain. Fabric committing peers provides an event stream to publish events to registered listeners. As of v1.0, the only events that get published are Block events. A Block event gets published whenever the committing peer adds a validated block to the ledger. There are three ways to register a listener to get notified: register a &quot;block listener&quot; to get called for every block event on all channels. The listener will be passed a fully decoded Block object. See registerBlockEvent register a &quot;transaction listener&quot; to get called when the specific transaction by id is committed (discovered inside a block event). The listener will be passed the transaction id and the validation code. See registerTxEvent register a &quot;chaincode event listener&quot; to get called when a specific chaincode event has arrived. The listener will be passed the ChaincodeEvent. See registerChaincodeEvent The events are ephemeral, such that if a registered listener crashed when the event is published, the listener will miss the event. There are several techniques to compensate for missed events due to client crashes: register block event listeners and record the block numbers received, such that when the next block arrives and its number is not the next in sequence, then the application knows exactly which block events have been missed. It can then use queryBlock to get those missed blocks from the target peer. use a message queue to catch all the block events. With many robust message queue implementations available today, you will be guaranteed to not miss an event. A fabric event listener can be written in any programming language. The following implementations can be used as reference to write the necessary glue code between the fabric event stream and a message queue: Node.js: this class. Source code can be found here Java: part of the Java SDK for Hyperledger Fabric. Source code can be found here Golang: an example event listener client can be found here new EventHub(clientContext) Constructs an EventHub object Parameters: Name Type Description clientContext Client An instance of the Client class which has already been initialzed with a userContext. Example var eh = client.newEventHub(); eh.setPeerAddr( 'grpcs://localhost:7053', { pem: Buffer.from(certdata).toString(), 'ssl-target-name-override': 'peer1'] } ); // register the listeners before calling &quot;connect()&quot; so that we can // have the error callback ready to process an error in case the // connect() call fails eh.registerTxEvent( transactionId, (tx, code) =&gt; { eh.unregisterTxEvent(transactionId); console.log(util.format('Transaction %s has completed', transactionId)); }, (err) =&gt; { eh.unregisterTxEvent(transactionId); console.log(util.format('Error %s! Transaction listener for %s has been ' + 'deregistered with %s', transactionId, err, eh.getPeerAddr())); } ); eh.connect(); Methods connect() Establishes a connection with the peer event source. The peer address must be set by calling the setPeerAddr() method before calling this method. The connection will be established asynchronously. If the connection fails to get established, the application will be notified via the error callbacks from the registerXXXEvent() methods. It is recommended that an application always registers at least one event listener with an error callback, by calling any one of the registerBlockEvent, registerTxEvent or registerChaincodeEvent methods, before calling connect(). disconnect() Disconnects the event hub from the peer event source. Will close all event listeners and send an Error object with the message &quot;EventHub has been shutdown&quot; to all listeners that provided an &quot;onError&quot; callback. getPeerAddr() Return the peer url of this event hub object isconnected() Is the event hub connected to the event source? Returns: True if connected to the event source, false otherwise Type boolean registerBlockEvent(onEvent, onError) Register a listener to receive all block events from all the channels that the target peer is part of. The listener's &quot;onEvent&quot; callback gets called on the arrival of every block. If the target peer is expected to participate in more than one channel, then care must be taken in the listener's implementation to differentiate blocks from different channels. See the example below on how to accomplish that. An error may be thrown by this call if no &quot;onError&quot; callback is provided and this EventHub has noticed that the connection has not been established. However since the connection establishment is running asynchronously, a register call could be made before this EventHub has been notified of the network issue. The best practice would be to provide an &quot;onError&quot; callback to be notified when this EventHub has an issue. Parameters: Name Type Description onEvent function Callback function that takes a single parameter of a Block object onError function Optional callback function to be notified when this event hub is shutdown. The shutdown may be caused by a network error or by a call to the &quot;disconnect()&quot; method or a connection error. Returns: This is the block registration number that must be sed to unregister (see unregisterBlockEvent) Type int Example Find out the channel Id of the arriving block eh.registerBlockEvent( (block) =&gt; { var first_tx = block.data.data[0]; // get the first transaction var header = first_tx.payload.header; // the &quot;header&quot; object contains metadata of the transaction var channel_id = header.channel_header.channel_id; if (&quot;mychannel&quot; !== channel_id) return; // do useful processing of the block }, (err) =&gt; { console.log('Oh snap!'); } ); registerChaincodeEvent(ccid, eventname, onEvent, onError) Register a listener to receive chaincode events. An error may be thrown by this call if no &quot;onError&quot; callback is provided and this EventHub has noticed that the connection has not been established. However since the connection establishment is running asynchronously, a register call could be made before this EventHub has been notified of the network issue. The best practice would be to provide an &quot;onError&quot; callback to be notified when this EventHub has an issue. Parameters: Name Type Description ccid string Id of the chaincode of interest eventname string The exact name of the chaincode event (must match the name given to the target chaincode's call to stub.SetEvent(name, payload)), or a regex string to match more than one event by this chaincode onEvent function callback function for matched events. It gets passed a single parameter which is a ChaincodeEvent object onError function Optional callback function to be notified when this event hub is shutdown. The shutdown may be caused by a network error or by a call to the &quot;disconnect()&quot; method or a connection error. Returns: An object that should be treated as an opaque handle used to unregister (see unregisterChaincodeEvent) Type Object registerTxEvent(txid, onEvent, onError) Register a callback function to receive a notification when the transaction by the given id has been committed into a block. An error may be thrown by this call if no &quot;onError&quot; callback is provided and this EventHub has noticed that the connection has not been established. However since the connection establishment is running asynchronously, a register call could be made before this EventHub has been notified of the network issue. The best practice would be to provide an &quot;onError&quot; callback to be notified when this EventHub has an issue. Parameters: Name Type Description txid string Transaction id string onEvent function Callback function that takes a parameter of type Transaction, and a string parameter which indicates if the transaction is valid (code = 'VALID'), or not (code string indicating the reason for invalid transaction) onError function Optional callback function to be notified when this event hub is shutdown. The shutdown may be caused by a network error or by a call to the &quot;disconnect()&quot; method or a connection error. setPeerAddr(peeraddr, opts) Set peer event source url. Parameters: Name Type Description peeraddr string grpc or grpcs URL for the target peer's event source opts ConnectionOpts The options for the connection to the peer. unregisterBlockEvent(The) Unregister the block event listener using the block registration number that is returned by the call to the registerBlockEvent() method. Parameters: Name Type Description The int block registration number that was returned during registration. unregisterChaincodeEvent(listener_handle) Unregister the chaincode event listener represented by the listener_handle object returned by the registerChaincodeEvent() method Parameters: Name Type Description listener_handle Object The handle object returned from the call to registerChaincodeEvent. unregisterTxEvent(txid) Unregister transaction event listener for the transaction id. Parameters: Name Type Description txid string The transaction id × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"FabricCAClient.html":{"id":"FabricCAClient.html","title":"Class: FabricCAClient","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: FabricCAClient FabricCAClient Client for communciating with the Fabric CA APIs new FabricCAClient(connect_opts) constructor Parameters: Name Type Description connect_opts object Connection options for communciating with the Fabric CA server Properties Name Type Description protocol string The protocol to use (either HTTP or HTTPS) hostname string The hostname of the Fabric CA server endpoint port number The port of the Fabric CA server endpoint tlsOptions TLSOptions The TLS settings to use when the Fabric CA endpoint uses &quot;https&quot; caname string The optional name of the CA. Fabric-ca servers support multiple Certificate Authorities from a single server. If omitted or null or an empty string, then the default CA is the target of requests Methods &lt;static&gt; pemToDER({string)) Convert a PEM encoded certificate to DER format Parameters: Name Type Description {string) pem PEM encoded public or private key Throws: Will throw an error if the conversation fails Returns: hex Hex-encoded DER bytes Type string enroll(enrollmentID, enrollmentSecret, csr, profile, attr_reqs) Enroll a registered user in order to receive a signed X509 certificate Parameters: Name Type Description enrollmentID string The registered ID to use for enrollment enrollmentSecret string The secret associated with the enrollment ID csr string PEM-encoded PKCS#10 certificate signing request profile string The profile name. Specify the 'tls' profile for a TLS certificate; otherwise, an enrollment certificate is issued. attr_reqs Array.&lt;AttributeRequest&gt; An array of AttributeRequest Throws: Will throw an error if all parameters are not provided Will throw an error if calling the enroll API fails for any reason Returns: EnrollmentResponse Type Promise newAffiliationService() Create a new AffiliationService object Returns: object Type AffiliationService newIdentityService(enrollmentID) Creates a new IdentityService object Parameters: Name Type Description enrollmentID The enrollment ID associated for this identity Returns: object Type IdentityService reenroll(csr, signingIdentity, attr_reqs) Re-enroll an existing user. Parameters: Name Type Description csr string PEM-encoded PKCS#10 certificate signing request signingIdentity SigningIdentity The instance of a SigningIdentity encapsulating the attr_reqs Array.&lt;AttributeRequest&gt; An array of AttributeRequest Returns: EnrollmentResponse Type Promise register(enrollmentID, enrollmentSecret, role, affiliation, maxEnrollments, attrs, signingIdentity) Register a new user and return the enrollment secret Parameters: Name Type Description enrollmentID string ID which will be used for enrollment enrollmentSecret string Optional enrollment secret to set for the registered user. If not provided, the server will generate one. When not including, use a null for this parameter. role string Optional type of role for this user. When not including, use a null for this parameter. affiliation string Affiliation with which this user will be associated maxEnrollments number The maximum number of times the user is permitted to enroll attrs Array.&lt;KeyValueAttribute&gt; Array of key/value attributes to assign to the user signingIdentity SigningIdentity The instance of a SigningIdentity encapsulating the signing certificate, hash algorithm and signature algorithm Returns: The enrollment secret to use when this user enrolls Type Promise revoke(enrollmentID, aki, serial, reason, signingIdentity) Revoke an existing certificate (enrollment certificate or transaction certificate), or revoke all certificates issued to an enrollment id. If revoking a particular certificate, then both the Authority Key Identifier and serial number are required. If revoking by enrollment id, then all future requests to enroll this id will be rejected. Parameters: Name Type Description enrollmentID string ID to revoke aki string Authority Key Identifier string, hex encoded, for the specific certificate to revoke serial string Serial number string, hex encoded, for the specific certificate to revoke reason string The reason for revocation. See https://godoc.org/golang.org/x/crypto/ocsp for valid values signingIdentity SigningIdentity The instance of a SigningIdentity encapsulating the signing certificate, hash algorithm and signature algorithm Returns: The revocation results Type Promise × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"FabricCAServices.html":{"id":"FabricCAServices.html","title":"Class: FabricCAServices","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: FabricCAServices FabricCAServices This is an implementation of the member service client which communicates with the Fabric CA server. new FabricCAServices(url, tlsOptions, caName, cryptoSuite) constructor Parameters: Name Type Description url string | object The endpoint URL for Fabric CA services of the form: &quot;http://host:port&quot; or &quot;https://host:port&quot; When this parameter is an object then it must include the parameters listed as key value pairs. tlsOptions TLSOptions The TLS settings to use when the Fabric CA services endpoint uses &quot;https&quot; caName string The optional name of the CA. Fabric-ca servers support multiple Certificate Authorities from a single server. If omitted or null or an empty string, then the default CA is the target of requests cryptoSuite CryptoSuite The optional cryptoSuite instance to be used if options other than defaults are needed. If not specified, an instance of CryptoSuite will be constructed based on the current configuration settings: - crypto-hsm: use an implementation for Hardware Security Module (if set to true) or software-based key management (if set to false) - crypto-keysize: security level, or key size, to use with the digital signature public key algorithm. Currently ECDSA is supported and the valid key sizes are 256 and 384 - crypto-hash-algo: hashing algorithm - key-value-store: some CryptoSuite implementation requires a key store to persist private keys. A CryptoKeyStore is provided for this purpose, which can be used on top of any implementation of the KeyValueStore interface, such as a file-based store or a database-based one. The specific implementation is determined by the value of this configuration setting. Extends BaseClient Methods enroll(req) Enroll the member and return an opaque member object. Parameters: Name Type Description req the EnrollmentRequest Returns: Promise for an object with &quot;key&quot; for private key and &quot;certificate&quot; for the signed certificate generateCRL(request, registrar) Parameters: Name Type Description request Restriction registrar User The identity of the registrar (i.e. who is performing the revocation) Returns: The Certificate Revocation List (CRL) Type Promise getCaName() Returns the name of the certificate authority. Returns: caName Type string getCryptoSuite() Returns the CryptoSuite object used by this client instance Inherited From: BaseClient#getCryptoSuite Returns: Type module:api.CryptoSuite newAffiliationService() Create a new AffiliationService object Returns: object Type AffiliationService newIdentityService() Creates a new IdentityService object Returns: object Type IdentityService reenroll(currentUser, Optional) Re-enroll the member in cases such as the existing enrollment certificate is about to expire, or it has been compromised Parameters: Name Type Description currentUser User The identity of the current user that holds the existing enrollment certificate Optional Array.&lt;AttributeRequest&gt; an array of AttributeRequest that indicate attributes to be included in the certificate Returns: Promise for an object with &quot;key&quot; for private key and &quot;certificate&quot; for the signed certificate register(req, registrar) Register the member and return an enrollment secret. Parameters: Name Type Description req RegisterRequest The RegisterRequest registrar User . The identity of the registrar (i.e. who is performing the registration) Returns: The enrollment secret to use when this user enrolls Type Promise revoke(request, registrar) Revoke an existing certificate (enrollment certificate or transaction certificate), or revoke all certificates issued to an enrollment id. If revoking a particular certificate, then both the Authority Key Identifier and serial number are required. If revoking by enrollment id, then all future requests to enroll this id will be rejected. Parameters: Name Type Description request Object Request object with the following fields: - enrollmentID {string}. ID to revoke - aki {string}. Authority Key Identifier string, hex encoded, for the specific certificate to revoke - serial {string}. Serial number string, hex encoded, for the specific certificate to revoke - reason {string}. The reason for revocation. See https://godoc.org/golang.org/x/crypto/ocsp for valid values. The default value is 0 (ocsp.Unspecified). registrar User The identity of the registrar (i.e. who is performing the revocation) Returns: The revocation results Type Promise setCryptoSuite(cryptoSuite) Sets the client instance to use the CryptoSuite object for signing and hashing Creating and setting a CryptoSuite is optional because the client will construct an instance based on default configuration settings: crypto-hsm: use an implementation for Hardware Security Module (if set to true) or software-based key management (if set to false) crypto-keysize: security level, or key size, to use with the digital signature public key algorithm. Currently ECDSA is supported and the valid key sizes are 256 and 384 crypto-hash-algo: hashing algorithm key-value-store: some CryptoSuite implementation requires a key store to persist private keys. A CryptoKeyStore is provided for this purpose, which can be used on top of any implementation of the KeyValueStore interface, such as a file-based store or a database-based one. The specific implementation is determined by the value of this configuration setting. Parameters: Name Type Description cryptoSuite module:api.CryptoSuite the CryptoSuite object Inherited From: BaseClient#setCryptoSuite toString() return a printable representation of this object × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"FileKeyValueStore.html":{"id":"FileKeyValueStore.html","title":"Class: FileKeyValueStore","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: FileKeyValueStore FileKeyValueStore This is a default implementation of the KeyValueStore API. It uses files to store the key values. new FileKeyValueStore(options) constructor Parameters: Name Type Description options Object contains a single property path which points to the top-level directory for the store Extends module:api.KeyValueStore Methods getValue(name) Get the value associated with name. Parameters: Name Type Description name string Name of the key Inherited From: module:api.KeyValueStore#getValue Overrides: module:api.KeyValueStore#getValue Returns: Promise for the value corresponding to the key. If the value does not exist in the store, returns null without rejecting the promise Type Promise setValue(name, value) Set the value associated with name. Parameters: Name Type Description name string Name of the key to save value string The Value to save Inherited From: module:api.KeyValueStore#setValue Overrides: module:api.KeyValueStore#setValue Returns: Promise for the 'value' object upon successful write operation Type Promise × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"global.html#Identity":{"id":"global.html#Identity","title":"Class: Identity","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: Identity Identity This interface is shared within the peer and client API of the membership service provider. Identity interface defines operations associated to a &quot;certificate&quot;. That is, the public part of the identity could be thought to be a certificate, and offers solely signature verification capabilities. This is to be used at the client side when validating certificates that endorsements are signed with, and verifying signatures that correspond to these certificates. new Identity(certificate, publicKey, mspId, cryptoSuite) Parameters: Name Type Description certificate string HEX string for the PEM encoded certificate publicKey module:api.Key The public key represented by the certificate mspId string The associated MSP's mspId that manages this identity cryptoSuite module:api.CryptoSuite The underlying CryptoSuite implementation for the digital signature algorithm Methods getMSPId() Returns the identifier of the Membser Service Provider that manages this identity in terms of being able to understand the key algorithms and have access to the trusted roots needed to validate it Returns: Type string getOrganizationUnits() Returns the organization units this identity is related to as long as this is public information. In certain implementations this could be implemented by certain attributes that are publicly associated to that identity, or the identifier of the root certificate authority that has provided signatures on this certificate. Examples: - OrganizationUnit of a fabric-tcert that was signed by TCA under name &quot;Organization 1&quot;, would be &quot;Organization 1&quot;. - OrganizationUnit of an alternative implementation of tcert signed by a public CA used by organization &quot;Organization 1&quot;, could be provided in the clear as part of that tcert structure that this call would be able to return. Returns: Type string isValid() This uses the rules that govern this identity to validate it. E.g., if it is a fabric TCert implemented as identity, validate will check the TCert signature against the assumed root certificate authority. Returns: Type boolean serialize() Converts this identity to bytes Returns: protobuf-based serialization with two fields: &quot;mspid&quot; and &quot;certificate PEM bytes&quot; Type Buffer verify(msg, signature, opts) Verify a signature over some message using this identity as reference Parameters: Name Type Description msg Array.&lt;byte&gt; The message to be verified signature Array.&lt;byte&gt; The signature generated against the message &quot;msg&quot; opts Object Options include 'policy' and 'label' verifyAttributes() Verify attributes against the given attribute spec TODO: when this method's design is finalized × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"IdentityService.html":{"id":"IdentityService.html","title":"Class: IdentityService","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: IdentityService IdentityService This is an implementation of the Identity service which communicates with the Fabric CA server using the Fabric CA client FabricCAClient. new IdentityService() Methods create(req, registrar) Create a new identity with the Fabric CA server. An enrollment secret is returned which can then be used, along with the enrollment ID, to enroll a new identity. The caller must have `hf.Registrar` authority. Parameters: Name Type Description req IdentityRequest The IdentityRequest registrar User The identity of the registrar (i.e. who is performing the registration). Returns: Return the secret of this new identity Type Promise delete(enrollmentID, registrar) Delete an existing identity. The caller must have `hf.Registrar` authority. Parameters: Name Type Description enrollmentID string registrar User Returns: ServiceResponse Type Promise getAll(registrar) Get all identities that the registrar is entitled to see. Parameters: Name Type Description registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise getOne(enrollmentID, registrar) Get an identity. The caller must have `hf.Registrar` authority. Parameters: Name Type Description enrollmentID string Required. The enrollment ID which uniquely identifies an identity registrar User Required. The identity of the registrar (i.e. who is performing the registration). Returns: ServiceResponse Type Promise update(enrollmentID, req, registrar) Update an existing identity. The caller must have `hf.Registrar` authority. Parameters: Name Type Description enrollmentID string req IdentityRequest registrar User Returns: ServiceResponse Type Promise × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"module.exports_module.exports.html":{"id":"module.exports_module.exports.html","title":"Class: exports","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: exports exports new exports(key) this class represents the private or public key of an ECDSA key pair. Parameters: Name Type Description key Object This must be the &quot;privKeyObj&quot; or &quot;pubKeyObj&quot; part of the object generated by jsrsasign.KEYUTIL.generateKeypair() × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"module-api.html":{"id":"module-api.html","title":"Module: api","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Module: api This module defines the APIs for the pluggable components of the node.js SDK. Classes CryptoSuite Key KeyValueStore × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"module-api.CryptoSuite.html":{"id":"module-api.CryptoSuite.html","title":"Class: CryptoSuite","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: CryptoSuite api. CryptoSuite Abstract class for a suite of crypto algorithms used by the SDK to perform digital signing, encryption/decryption and secure hashing. A complete suite includes support for asymmetric keys (such as ECDSA or RSA), symmetric keys (such as AES) and secure hash (such as SHA2/3). The SDK provides a default implementation based on ECDSA + SHA2/3. An alternative implementation can be specified using the &quot;crypto-suite-software&quot; configuration setting, pointing to a full require() path to the package for the module. new CryptoSuite() Methods decrypt(key, cipherText, opts) Decrypts ciphertext using key. The opts argument should be appropriate for the algorithm used. Parameters: Name Type Description key module:api.Key Decryption key (private key) cipherText Array.&lt;byte&gt; Cipher text to decrypt opts Object Decrypt options Returns: Plain text after decryption Type Array.&lt;byte&gt; deriveKey(key) Derives the new private key from the source public key using the parameters passed in the opts. This operation is needed for deriving private keys corresponding to the Transaction Certificates. Parameters: Name Type Description key module:api.Key The source key Returns: Derived key Type module:api.Key encrypt(key, plainText, opts) Encrypts plaintext using key. The opts argument should be appropriate for the algorithm used. Parameters: Name Type Description key module:api.Key Encryption key (public key) plainText Array.&lt;byte&gt; Plain text to encrypt opts Object Encryption options Returns: Cipher text after encryption Type Array.&lt;byte&gt; generateKey(opts) Generate a key using the options in opts. If the opts.ephemeral parameter is false, the method, in addition to returning the imported Key instance, also persists the generated key in the key store as PEM files that can be retrieved using the getKey() method Parameters: Name Type Description opts KeyOpts Optional Returns: Promise for an instance of the Key class Type module:api.Key getKey(ski) Returns the Key this implementation associates to the Subject Key Identifier ski. Parameters: Name Type Description ski string Subject Key Identifier specific to a Crypto Suite implementation, as the unique index to represent the key Returns: Promise of an instance of the Key class corresponding to the ski Type module:api.Key hash(msg, opts) Produce a hash of the message msg using options opts Parameters: Name Type Description msg string Source message to be hashed opts Object algorithm: an identifier for the algorithm to be used, such as &quot;SHA3&quot; Returns: The hashed digest in hexidecimal string encoding Type string importKey(pem, opts) Imports a Key from its raw representation using opts. If the opts.ephemeral parameter is false, the method, in addition to returning the imported Key instance, also saves the imported key in the key store as PEM files that can be retrieved using the 'getKey()' method Parameters: Name Type Description pem string PEM string of the key to import opts KeyOpts Optional Returns: If &quot;opts.ephemeral&quot; is true, returns the Key class synchronously. If &quot;opts.ephemeral&quot; not set or false, returns a Promise of an instance of the Key class. Type Key | Promise sign(key, digest) Signs digest using key. The opts argument should be appropriate for the algorithm used. Parameters: Name Type Description key module:api.Key Signing key (private key) digest Array.&lt;byte&gt; The message digest to be signed. Note that when a signature of a larger message is needed, the caller is responsible for hashing the larger message and passing the hash (as digest) to sign. Returns: the resulting signature Type Array.&lt;byte&gt; verify(key, signature, digest) Verifies signature against key and digest Parameters: Name Type Description key module:api.Key Signing verification key (public key) signature Array.&lt;byte&gt; The signature to verify digest Array.&lt;byte&gt; The digest that the signature was created for Returns: true if the signature verifies successfully Type boolean × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"module-api.Key.html":{"id":"module-api.Key.html","title":"Class: Key","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: Key api. Key Key represents a cryptographic key. It can be symmetric or asymmetric. In the case of an asymmetric key, the key can be public or private. In the case of a private asymmetric key, the getPublicKey() method allows to retrieve the corresponding public-key. A key can be referenced via the Subject Key Identifier (SKI) and resolvable by the appropriate CryptoSuite implementation new Key() Methods getPublicKey() Returns the corresponding public key if this key is an asymmetric private key. If this key is already public, returns this key itself. Returns: the corresponding public key if this key is an asymmetric private key. If this key is already public, returns this key itself. Type module:api.Key getSKI() Returns the subject key identifier of this key Returns: The subject key identifier of this key as a hexidecial encoded string Type string isPrivate() Returns true if this key is an asymmetric private key, false otherwise. Returns: if this key is an asymmetric private key Type boolean isSymmetric() Returns true if this key is a symmetric key, false is this key is asymmetric Returns: if this key is a symmetric key Type boolean toBytes() Converts this key to its PEM representation, if this operation is allowed. Returns: the PEM string representation of the key Type string × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"module-api.KeyValueStore.html":{"id":"module-api.KeyValueStore.html","title":"Class: KeyValueStore","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: KeyValueStore api. KeyValueStore Abstract class for a Key-Value store. The Channel class uses this store to save sensitive information such as authenticated user's private keys, certificates, etc. The SDK provides a default implementation based on files. An alternative implementation can be specified using the &quot;key-value-store&quot; configuration setting, pointing to a full require() path to package for the module. new KeyValueStore() Methods getValue(name) Get the value associated with name. Parameters: Name Type Description name string Name of the key Returns: Promise for the value corresponding to the key. If the value does not exist in the store, returns null without rejecting the promise Type Promise setValue(name, value) Set the value associated with name. Parameters: Name Type Description name string Name of the key to save value string The Value to save Returns: Promise for the 'value' object upon successful write operation Type Promise × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"MSP.html":{"id":"MSP.html","title":"Class: MSP","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: MSP MSP MSP is the minimal Membership Service Provider Interface to be implemented to manage identities (in terms of signing and signature verification) represented by private keys and certificates generated from different algorithms (ECDSA, RSA, etc) and PKIs (software-managed or HSM based) new MSP(config) Setup the MSP instance according to configuration information Parameters: Name Type Description config Object A configuration object specific to the implementation. For this implementation it uses the following fields: `rootCerts`: array of Identity representing trust anchors for validating signing certificates. Required for MSPs used in verifying signatures `intermediateCerts`: array of Identity representing trust anchors for validating signing certificates. optional for MSPs used in verifying signatures `admins`: array of Identity representing admin privileges `signer`: SigningIdentity signing identity. Required for MSPs used in signing `id`: {string} value for the identifier of this instance `orgs`: {string} array of organizational unit identifiers `cryptoSuite': the underlying module:api.CryptoSuite for crypto primitive operations Methods deserializeIdentity(serializedIdentity, storeKey) DeserializeIdentity deserializes an identity Parameters: Name Type Description serializedIdentity Array.&lt;byte&gt; A protobuf-based serialization of an object with two fields: mspid and idBytes for certificate PEM bytes storeKey boolean if the user should be stored in the key store. Only when false will a promise not be returned Returns: Promise for an Identity instance or or the Identity object itself if &quot;storeKey&quot; argument is false Type Promise getDefaultSigningIdentity() Returns the default signing identity Returns: Type SigningIdentity getId() Get provider identifier Returns: Type string getOrganizationUnits() Get organizational unit identifiers Returns: Type Array.&lt;string&gt; getPolicy() Obtain the policy to govern changes Returns: Type Object getSigningIdentity(identifier) Returns a signing identity corresponding to the provided identifier Parameters: Name Type Description identifier string The identifier of the requested identity object Returns: Type SigningIdentity toProtobuf() Returns the Protobuf representation of this MSP Config validate(id) Checks whether the supplied identity is valid Parameters: Name Type Description id Identity Returns: Type boolean × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"MSPManager.html":{"id":"MSPManager.html","title":"Class: MSPManager","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: MSPManager MSPManager MSPManager is an interface defining a manager of one or more MSPs. This essentially acts as a mediator to MSP calls and routes MSP related calls to the appropriate MSP. This object is immutable, it is initialized once and never changed. new MSPManager() Methods addMSP(config) Create and add MSP instance to this manager according to configuration information Parameters: Name Type Description config Object A configuration object specific to the implementation. For this implementation it uses the following fields: `rootCerts`: array of Identity representing trust anchors for validating signing certificates. Required for MSPs used in verifying signatures `intermediateCerts`: array of Identity representing trust anchors for validating signing certificates. optional for MSPs used in verifying signatures `admins`: array of Identity representing admin privileges `signer`: SigningIdentity signing identity. Required for MSPs used in signing `id`: {string} value for the identifier of this instance `orgs`: {string} array of organizational unit identifiers `cryptoSuite': the underlying module:api.CryptoSuite for crypto primitive operations Returns: The newly created MSP instance Type MSP deserializeIdentity(serializedIdentity) DeserializeIdentity deserializes an identity Parameters: Name Type Description serializedIdentity Array.&lt;byte&gt; A protobuf-based serialization of an object with two fields: mspid and idBytes for certificate PEM bytes Returns: Promise for an Identity instance Type Promise getMSP() Returns a validating MSP getMSPs() Returns the validating MSPs. Note that this does NOT return the local MSP loadMSPs(mspConfigs) Instantiates MSPs for validating identities (like the endorsor in the ProposalResponse). The MSPs loaded via this method require the CA certificate representing the Certificate Authority that signed the identities to be validated. They also optionally contain the certificates for the administrators of the organization that the CA certs represent. Parameters: Name Type Description mspConfigs protos/msp/mspconfig.proto An array of MSPConfig objects as defined by the protobuf protos/msp/mspconfig.proto × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"NetworkConfig_1_0.html":{"id":"NetworkConfig_1_0.html","title":"Class: NetworkConfig_1_0","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: NetworkConfig_1_0 NetworkConfig_1_0 This is an implementation of the NetworkConfig API. It will be used to work with the v1.0.1 version of a JSON based network configuration. new NetworkConfig_1_0(network_config) constructor Parameters: Name Type Description network_config Object Network Configuration as represented in a JSON object Extends module:api.NetworkConfig × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"Orderer.html":{"id":"Orderer.html","title":"Class: Orderer","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: Orderer Orderer The Orderer class encapsulates the client capabilities to interact with an Orderer node in the target blockchain network. The orderer node exposes two APIs: broadcast() and deliver(). Both are streaming APIs so there's a persistent grpc streaming connection between the client and the orderer where messages are exchanged in both directions. The broadcast() API is for sending transactions to the orderer for processing. The deliver() API is for asking the orderer for information such as channel configurations. new Orderer(url, opts) Constructs an Orderer object with the given url and opts. An orderer object encapsulates the properties of an orderer node and the interactions with it via the grpc stream API. Orderer objects are used by the Client objects to broadcast requests for creating and updating channels. They are also used by the Channel objects to broadcast requests for ordering transactions. Parameters: Name Type Description url string The URL with format of &quot;grpc(s)://host:port&quot;. opts ConnectionOpts The options for the connection to the orderer. Methods close() Close the service connection. sendBroadcast(envelope) Send a Broadcast message to the orderer service. Parameters: Name Type Description envelope Array.&lt;byte&gt; Byte data to be included in the broadcast. This must be a protobuf encoded byte array of the common.Envelope that contains either a ConfigUpdateEnvelope or a Transaction in the payload.data property of the envelope. Returns: A Promise for a BroadcastResponse object Type Promise sendDeliver(envelope) Send a Deliver message to the orderer service. Parameters: Name Type Description envelope Array.&lt;byte&gt; Byte data to be included in the broadcast. This must be a protobuf encoded byte array of the common.Envelope that contains a SeekInfo in the payload.data property of the envelope. The header.channelHeader.type must be set to common.HeaderType.DELIVER_SEEK_INFO Returns: A Promise for a protobuf object of type common.Block. Note that this is NOT the same type of object as the Block returned by the BlockDecoder.decode() method and various other methods. A Block is a pure javascript object, whereas the object returned by this method is a protobuf object that contains accessor methods, getters and setters, and toBuffer() for each property to be used for further manipulating the object and convert to and from byte arrays. Type Promise toString() return a printable representation of this object × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"Organization.html":{"id":"Organization.html","title":"Class: Organization","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: Organization Organization The Organization class represents an organization in the target blockchain network. new Organization(name, mspid) Construct a Organization object Parameters: Name Type Description name string The name of this organization mspid string The mspid of this organization Methods addCertificateAuthority(certificateAuthority) Add a CertificateAuthority to this organization Parameters: Name Type Description certificateAuthority CertificateAuthority The CertificateAuthority instance to add to this organizations list of CertificateAuthorities addEventHub(event_hub) Add a EventHub to this organizations Parameters: Name Type Description event_hub EventHub The event hub instance to add to this organization's list of event hubs addPeer(peer) Add a Peer to this organization Parameters: Name Type Description peer Peer The peer instance to add to this organizations list of peers getAdminCert() Gets the admin signing certificate in PEM format for this organization. getAdminPrivateKey() Gets the admin private key in PEM format for this organization. getCertificateAuthorities() Gets the list of this CertificateAuthorities CertificateAuthority Returns: [] An array of CertificateAuthority objects Type CertificateAuthority getChannelEventHubs(channel) Gets the list of this organization's ChannelEventHub as undefined by the 'endorsingPeer' setting on the peers defined in the channel that are in this orgranization. Parameters: Name Type Description channel Channel The Channel the channel instance that the peers that are defined as channel event hubs are associated. Returns: [] An array of ChannelEventHub objects Type ChannelEventHub getEventHubs() Gets the list of this organization's EventHub Returns: [] An array of EventHub objects Type EventHub getMspid() Gets the MSPID of this organization Returns: The mspid of this organization Type string getName() Gets the name of this organization Returns: The name of this organization Type string getPeers() Gets the list of this organizations Peer Returns: [] An array of Peer objects Type Peer setAdminCert() Sets the admin signing certificate in PEM format for this organization. setAdminPrivateKey() Sets the admin private key in PEM format for this organization. toString() return a printable representation of this object × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"Peer.html":{"id":"Peer.html","title":"Class: Peer","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: Peer Peer The Peer class represents a peer in the target blockchain network. The application can send endorsement proposals, and query requests through this class. new Peer(url, opts) Construct a Peer object with the given url and opts. A peer object encapsulates the properties of an endorsing peer and the interactions with it via the grpc service API. Peer objects are used by the Client objects to send channel-agnostic requests such as installing chaincode, querying peers for installed chaincodes, etc. They are also used by the Channel objects to send channel-aware requests such as instantiating chaincodes, and invoking transactions. Parameters: Name Type Description url string The URL with format of &quot;grpc(s)://host:port&quot;. opts ConnectionOpts The options for the connection to the peer. Extends Remote Methods close() Close the service connection. getClientCertHash() Get the client certificate hash Inherited From: Remote#getClientCertHash Returns: The hash of the client certificate Type Array.&lt;byte&gt; getName() Get the name. This is a client-side only identifier for this object. Inherited From: Remote#getName Returns: The name of the object Type string getUrl() Get the URL of this object. Inherited From: Remote#getUrl Returns: Get the URL associated with the object. Type string isInRole() Checks if this peer is in the specified role. The default is true when the incoming role is not defined. The default will be true when this peer does not have the role defined. sendProposal(proposal, timeout) Send an endorsement proposal to an endorser. This is used to call an endorsing peer to execute a chaincode to process a transaction proposal, or runs queries. Parameters: Name Type Description proposal Proposal A protobuf encoded byte array of type Proposal timeout Number A number indicating milliseconds to wait on the response before rejecting the promise with a timeout error. This overrides the default timeout of the Peer instance and the global timeout in the config settings. Returns: A Promise for a ProposalResponse Type Promise setName(name) Set the name as a client-side only identifier of this object. Parameters: Name Type Description name string Inherited From: Remote#setName setRole(role, isIn) Set a role for this peer. Parameters: Name Type Description role string The name of the role isIn boolean The boolean value of does this peer have this role toString() return a printable representation of this object Overrides: Remote#toString × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"PKCS11_ECDSA_KEY.html":{"id":"PKCS11_ECDSA_KEY.html","title":"Class: PKCS11_ECDSA_KEY","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: PKCS11_ECDSA_KEY PKCS11_ECDSA_KEY new PKCS11_ECDSA_KEY() This module implements the module:api.Key interface, for ECDSA key management by Hardware Security Module support via PKCS#11 interface. Extends module:api.Key Methods getPublicKey() Returns the corresponding public key if this key is an asymmetric private key. If this key is already public, returns this key itself. Inherited From: module:api.Key#getPublicKey Overrides: module:api.Key#getPublicKey Returns: the corresponding public key if this key is an asymmetric private key. If this key is already public, returns this key itself. Type module:api.Key getSKI() Returns the subject key identifier of this key Inherited From: module:api.Key#getSKI Overrides: module:api.Key#getSKI Returns: The subject key identifier of this key as a hexidecial encoded string Type string isPrivate() Returns true if this key is an asymmetric private key, false otherwise. Inherited From: module:api.Key#isPrivate Overrides: module:api.Key#isPrivate Returns: if this key is an asymmetric private key Type boolean isSymmetric() Returns true if this key is a symmetric key, false is this key is asymmetric Inherited From: module:api.Key#isSymmetric Overrides: module:api.Key#isSymmetric Returns: if this key is a symmetric key Type boolean toBytes() Converts this key to its PEM representation, if this operation is allowed. Inherited From: module:api.Key#toBytes Overrides: module:api.Key#toBytes Returns: the PEM string representation of the key Type string × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"Remote.html":{"id":"Remote.html","title":"Class: Remote","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: Remote Remote The Remote class represents a the base class for all remote nodes, Peer, Orderer , and MemberServicespeer. new Remote(url, opts) Constructs an object with the endpoint configuration settings. Parameters: Name Type Description url string The orderer URL with format of 'grpc(s)://host:port'. opts Object An Object that may contain options to pass to grpcs calls - pem {string} The certificate file, in PEM format, to use with the gRPC protocol (that is, with TransportCredentials). Required when using the grpcs protocol. - clientKey {string} The private key file, in PEM format, to use with the gRPC protocol (that is, with TransportCredentials). Required when using the grpcs protocol with client certificates. - clientCert {string} The public certificate file, in PEM format, to use with the gRPC protocol (that is, with TransportCredentials). Required when using the grpcs protocol with client certificates. - ssl-target-name-override {string} Used in test environment only, when the server certificate's hostname (in the 'CN' field) does not match the actual host endpoint that the server process runs at, the application can work around the client TLS verify failure by setting this property to the value of the server certificate's hostname - any other standard grpc call options will be passed to the grpc service calls directly Methods getClientCertHash() Get the client certificate hash Returns: The hash of the client certificate Type Array.&lt;byte&gt; getName() Get the name. This is a client-side only identifier for this object. Returns: The name of the object Type string getUrl() Get the URL of this object. Returns: Get the URL associated with the object. Type string setName(name) Set the name as a client-side only identifier of this object. Parameters: Name Type Description name string toString() return a printable representation of this object × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"Signer.html":{"id":"Signer.html","title":"Class: Signer","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: Signer Signer Signer is an interface for an opaque private key that can be used for signing operations new Signer(cryptoSuite, key) Parameters: Name Type Description cryptoSuite module:api.CryptoSuite The underlying CryptoSuite implementation for the digital signature algorithm key module:api.Key The private key Methods getPublicKey() Returns the public key corresponding to the opaque, private key Returns: The public key corresponding to the private key Type module:api.Key sign(digest, opts) Signs digest with the private key. Hash implements the SignerOpts interface and, in most cases, one can simply pass in the hash function used as opts. Sign may also attempt to type assert opts to other types in order to obtain algorithm specific values. Note that when a signature of a hash of a larger message is needed, the caller is responsible for hashing the larger message and passing the hash (as digest) and the hash function (as opts) to Sign. Parameters: Name Type Description digest Array.&lt;byte&gt; The message to sign opts Object hashingFunction: the function to use to hash × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"SigningIdentity.html":{"id":"SigningIdentity.html","title":"Class: SigningIdentity","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: SigningIdentity SigningIdentity SigningIdentity is an extension of Identity to cover signing capabilities. E.g., signing identity should be requested in the case of a client who wishes to sign proposal responses and transactions new SigningIdentity(certificate, publicKey, mspId, cryptoSuite, signer) Parameters: Name Type Description certificate string HEX string for the PEM encoded certificate publicKey module:api.Key The public key represented by the certificate mspId string The associated MSP's ID that manages this identity cryptoSuite module:api.CryptoSuite The underlying CryptoSuite implementation for the digital signature algorithm signer Signer The signer object encapsulating the opaque private key and the corresponding digital signature algorithm to be used for signing operations Methods sign(msg, opts) Signs digest with the private key contained inside the signer. Parameters: Name Type Description msg Array.&lt;byte&gt; The message to sign opts Object Options object for the signing, contains one field 'hashFunction' that allows different hashing algorithms to be used. If not present, will default to the hash function configured for the identity's own crypto suite object × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"TransactionID.html":{"id":"TransactionID.html","title":"Class: TransactionID","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: TransactionID TransactionID The class representing the transaction identifier. Provides for automatically creating the `nonce` value when an instance of this object is created. new TransactionID(signer_or_userContext, admin) Builds a new tranaction Id based on a user's certificate and an automatically generates a nonce value. Parameters: Name Type Description signer_or_userContext Identity An instance of Identity that provides an unique base for this transaction id. This also may be an instance of a {@User}. admin boolean Indicates that this instance will be used for administrative transactions. Methods getNonce() The nonce value getTransactionID() The transaction ID isAdmin() indicates if this transactionID was generated for an admin × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"User.html":{"id":"User.html","title":"Class: User","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Class: User User The User class represents users that have been enrolled and represented by an enrollment certificate (ECert) and a signing key. The ECert must have been signed by one of the CAs the blockchain network has been configured to trust. An enrolled user (having a signing key and ECert) can conduct chaincode instantiate, transactions and queries with the Channel. User ECerts can be obtained from a CA beforehand as part of installing and instantiating the application, or it can be obtained from the optional Fabric CA service via its enrollment process. Sometimes User identities are confused with Peer identities. User identities represent signing capability because it has access to the private key, while Peer identities in the context of the application/SDK only has the certificate for verifying signatures. An application cannot use the Peer identity to sign things because the application doesn’t have access to the Peer identity’s private key. new User(cfg) Constructor for a member. Parameters: Name Type Description cfg string The member name or an object with the following attributes: - enrollmentID {string}: user name - name {string}: user name, if &quot;enrollmentID&quot; is also specified, the &quot;name&quot; is ignored - roles {string[]}: optional. array of roles - affiliation {string}: optional. affiliation with a group or organization Methods fromString() Set the current state of this member from a string based JSON object Returns: Promise of the unmarshalled Member object represented by the serialized string Type Member getAffiliation() Get the affiliation. Returns: The affiliation. Type string getCryptoSuite() Get the module:api.CryptoSuite cryptoSuite object for this User instance. Returns: the cryptoSuite used to store crypto and key store settings Type module:api.CryptoSuite getIdentity() Get the Identity object for this User instance, used to verify signatures Returns: the identity object that encapsulates the user's enrollment certificate Type Identity getName() Get the member name. Returns: The member name. Type string getRoles() Get the roles. Returns: The roles. Type Array.&lt;string&gt; getSigningIdentity() Get the SigningIdentity object for this User instance, used to generate signatures Returns: the identity object that encapsulates the user's private key for signing Type SigningIdentity isEnrolled() Determine if this name has been enrolled. Returns: True if enrolled; otherwise, false. Type boolean setAffiliation(affiliation) Set the affiliation. Parameters: Name Type Description affiliation string The affiliation. setCryptoSuite(cryptoSuite) Set the cryptoSuite. When the application needs to use crypto settings or a key store other than the default, it needs to set a cryptoSuite instance that was created with the desired CryptoSuite settings and CryptoKeyStore options. Parameters: Name Type Description cryptoSuite module:api.CryptoSuite The cryptoSuite. setEnrollment(privateKey, certificate, mspId) Set the enrollment object for this User instance Parameters: Name Type Description privateKey module:api.Key the private key object certificate string the PEM-encoded string of certificate mspId string The Member Service Provider id for the local signing identity Returns: Promise for successful completion of creating the user's signing Identity Type Promise setRoles(roles) Set the roles. Parameters: Name Type Description roles Array.&lt;string&gt; The roles. toString() Save the current state of this member as a string Returns: The state of this member as a string Type string × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"tutorial-app-dev-env-setup.html":{"id":"tutorial-app-dev-env-setup.html","title":"Tutorial: Setting up the Application Developer's Environment","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER Setting up the Application Developer's Environment This tutorial describes how to prepare a development environment in order to build a business application to use a blockchain network based on Hyperledger Fabric. At a high level, a business application running on a Hyperledger Fabric network is made up of two parts: chaincode that runs in the servers (endorser nodes), and client code that runs in the Node.js application. For chaincode development, please visit the Hyperledger Fabric chaincode tutorials. For complete information on starting a Hyperledger Fabric network, please see the Build your first network tutorial. The following tutorial assumes a chaincode has been developed and the focus is developing the client application. What makes up a Hyperledger Fabric application development environment?Below you'll find a high level summary of the Hyperledger Fabric design aimed at an introductory level of understanding, so that you can be on your way to setting up the development environment. For a comprehensive description of the concepts, the architecture, please visit the official Hyperledger Fabric documentation. First of all, you will need an orderer. But isn't an orderer responsible for the consensus? Why start here? It's true that the main responsibility of the ordering service of a Hyperledger Fabric blockchain network is to provide consensus on a transaction among the maintainers of the ledger, a.k.a the committer nodes. However, the ordering service also maintains critical data about the overall network: what organizations are participating, what channels have been created, which organizations are part of a given channel, and last but not least what policies are in place for any kind of change to the network. In essence, the ordering service holds the network together. Ok we've got to have an orderer node so we can add participating organizations to it and get a network started. Next you would need peers for each participating organization in order to participate in transaction endorsing and maintaining the ledger. The peer nodes play two roles: endorser and committer. A peer's endorser role may be enabled or disabled based on the bootstrap configuration. Note that all peers are always committers. For high availability you would want more than one peer for each organization in a real deployment. For the development environment, one peer per organization is sufficient under most circumstances. This peer will be both an endorser and a committer. It will be sent transaction proposals to endorse and queries to discover information from the ledger. Another important role that peer nodes play is broadcasting events to interested parties. Whenever a block is added to the ledger, an event is sent by the peer through a dedicated streaming port. Any application within the organization can register themselves to listen on that port to get notified. The final piece of the puzzle is identities. Every operation in a Hyperledger Fabric network must be digitially signed for the purposes of access control, or provenance/auditing (who did what), or both. As of v1.0, identities are based on the Public Key Infrastructure (PKI)) standards. Every orderer node, every peer node and every user/transactor must have a key pair with the public key wrapped in a x.509 certificate signed by a Certificate Authority (CA). Since x.509 is an open standard, Hyperledger Fabric would work with any existing certificate authority. This is typically a painful process with lots of potential red tape to get real certificates, so for the development purposes it is a popular practice to use self-signed certificates locally generated. As you will see in the later section, the Hyperledger Fabric provides tools to make this less painful. Also related to identities, you should make a decision on whether Fabric-CA should be part of your solution. This is a server with REST APIs that supports dynamic identity management with registration, enrollment (getting certificates), revocation and re-enrollment. So it is very useful in providing user identities on the fly. Note that user identities provisioned this way are only of the MEMBER role, which means it won't be able to perform certain operations reserved for the ADMIN role: create/update channel install/instantiate chaincode query installed/instantiated chaincodes For these privileged operations, the client must use an ADMIN user to submit the request. If you choose to not use Fabric-CA, everything will still work, but the application is responsible for managing the user certificates. PrerequisitesYou will need the following software: Docker and Docker Compose - see Hyperledger Fabric for details Nodejs v6.2.0 - 6.10.0, 8.4.0+ ( Node v7+ is not supported ) Prepare crypto materialsAs discussed above, identities are established with x.509 certificates. If you think about it, we will need a whole bunch of certificates because there are many identities involved: peers need identities to sign endorsements orderers need identities to sign proposed blocks for the committers to validate and append to the ledger applications need identities to sign transaction requests the Fabric CA themselves also need identities, so their signatures in the certificates can be validated Luckily there is a tool for that. Follow this guide to use the cryptogen tool to generate all the required keys and certificates in one swoop. Note that the cryptogen tool will automatically generate identities for the Fabric CA nodes for each orderer and peer organization, which can be used to start the Fabric-CA servers (if you choose to use it as part of the solution as discussed above). In addition, it also generates one admin user of the ADMIN role with the privileges to perform admin-level operations listed above. Finally, it also generates regular users (MEMBER role) for submitting transactions. This would get us all the crypto materials needed to start things up. Getting things rolling for real - the genesis blockAs discussed above, the orderer should be the first step to bootstrap (launch) a network. The orderer will need the initial configurations wrapped inside a genesis block. Follow the instructions here to use the congigtxgen tool to generate a genesis.block. The output, a genesis block file for the orderer, will be used in the next step to launch the orderer node. Start the networkNow we are ready to put it all together. The easiest way to launch the development environment is to use docker-compose. Follow the instructions here to start the network. To minimize the chances of a mistake, you may wish to run the network without TLS. The above steps give you a development environment. Now before you can ask it to process any transactions, you must first create a channel. This work is licensed under a Creative Commons Attribution 4.0 International License. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"tutorial-channel-create.html":{"id":"tutorial-channel-create.html","title":"Tutorial: How to create a Hyperledger Fabric channel","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER How to create a Hyperledger Fabric channel This tutorial illustrates the creation of a Hyperledger Fabric channel using the Node.js fabric-client SDK. It shows how to use an initial (default) channel definition and how to start with that definition to build a custom definition. The process to create a network and channels also involves creating and working with cryptographic material, this will not be discussed here. For more information on: getting started with Hyperledger Fabric see Building your first network. the configuration of a channel in Hyperledger Fabric and the internal process of creating and updating see Hyperledger Fabric channel configuration cryptographic generation see cryptogen configuration transaction generator see configtxgen configuration translation tool see configtxlator The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), protobuf, and of Node application development, including the use of the Javascript Promise. The examples shown below are based on the balance-transfer sample application. see Hyperledger Fabric Samples steps of a channel create: run the configtxgen tool to generate a genesis block run the configtxgen tool to generate an initial binary configuration definition get a sign-able channel definition in one of two ways use the initial binary channel configuration definition use the fabric-client SDK to extract the sign-able channel definition from the initial binary channel configuration definition build a custom definition use the configtxlator to convert the initial binary channel configuration definition to readable text edit the readable text more info use the configtxlator to convert the edited text to a sign-able channel definition use the fabric-client SDK to sign the sign-able channel definition use the fabric-client SDK to send the signatures and the sign-able channel definition to the orderer use the fabric-client SDK to have the peer join the channel then new channel may be used Use the initial definition to build a sign-able channel definitionThe initial binary channel configuration definition generated by the configtxgen tool is a binary file containing the Hyperledger Fabric configuration protobuf common.Envelope element. Inside this element is the common.ConfigUpdate protobuf element. This configuration element is the one that must be signed. A profile element in the configtx.yaml is the source for the initial binary channel configuration definition created by the configtxgen tool. ../../../bin/configtxgen -channelID mychannel -outputCreateChannelTx mychannel.tx -profile TwoOrgsChannelHave the fabric-client SDK extract the config update element from the mychannel.tx file // first read in the file, this gives us a binary config envelope let envelope_bytes = fs.readFileSync(path.join(__dirname, 'fabric-samples/balance-transfer/artifacts/channel/mychannel.tx')); // have the nodeSDK extract out the config update var config_update = client.extractChannelConfig(envelope_bytes);The binary config_update may now be used in the signing process and sent to the orderer for channel creation. You may ask why is a common.ConfigUpdate used for a create. This makes the process of create and update the same. The create of a new channel is a delta on what is defined in the system channel and an update is a delta on what is defined in the channel. The common.ConfigUpdate object submitted will only contain the changes for both a create and an update. Creating a custom sign-able channel definitionThe easiest way to get started with creating a custom channel configuration is to have the configtxlator convert an existing binary that has been or could be used to create a new channel to human readable JSON. There are many elements of the configuration and it would be very difficult to start with nothing. Using the same configtx.yaml file used to generate your Hyperledger Fabric network, use the configtxgen tool to create a initial binary configuration definition for a new channel. Then by sending that binary to the configtxlator to convert it to JSON, you will be able to see the layout and have a starting point. That JSON could also be used as a template for creating other new channels on your network. A new channel will inherit settings from the system channel for settings not defined in the new channel configuration. Organizations that will be on the new channel must be defined in a consortium on the system channel. Therefore having the readable definition of the system channel of your network would be helpful when creating a new channel. Send the genesis.block that was used to start the Hyperledger Fabric network to the configtxlator to get a JSON file to be used as a reference. Use the configtxgen tool to produce the binary config files. From the sample directory fabric-samples/balance-transfer/artifacts/channel. export FABRIC_CFG_PATH=$PWD ../../../bin/configtxgen -outputBlock genesis.block -profile TwoOrgsOrdererGenesis ../../../bin/configtxgen -channelID mychannel -outputCreateChannelTx mychannel.tx -profile TwoOrgsChannel Send the two binary files to the configtxlator service. Since this step is done only once and does not require a Node.js application, we will use cURL to simplify and speed up getting the results. Notice that configtxlator service path has decode (convert from binary to JSON). The path must also include the type of object of the binary, in the first case, it is a common.Block. The &quot;decode&quot; or &quot;encode&quot; may be done for any of the protobuf message object types found in the fabric-client\\lib\\protos directory protobuf files. First start the configtxlator service, from the fabric-samples/bin directory ./configtxlator startThen curl -X POST --data-binary @genesis.block http://127.0.0.1:7059/protolator/decode/common.Block &gt; genesis.json curl -X POST --data-binary @mychannel.tx http://127.0.0.1:7059/protolator/decode/common.Envelope &gt; mychannel.jsonThe results of decoding the file mychannel.tx which is a common.Envelope produced by the configtxgen tool contains a common.ConfigUpdate object. This object has the name &quot;config_update&quot; within the &quot;payload.data&quot; JSON object. This is the object that is needed as the source of the template to be used for creating new channels. The common.ConfigUpdate is the object that will be signed by all organizations and submitted to the orderer to create a new channel. The following is the extracted JSON &quot;config_update&quot; (common.ConfigUpdate) object from the decode of the &quot;TwoOrgsChannel&quot; channel create binary generated above. { &quot;channel_id&quot;: &quot;mychannel&quot;, &quot;read_set&quot;: { &quot;groups&quot;: { &quot;Application&quot;: { &quot;groups&quot;: { &quot;Org1MSP&quot;: {} } } }, &quot;values&quot;: { &quot;Consortium&quot;: { &quot;value&quot;: { &quot;name&quot;: &quot;SampleConsortium&quot; } } } }, &quot;write_set&quot;: { &quot;groups&quot;: { &quot;Application&quot;: { &quot;groups&quot;: { &quot;Org1MSP&quot;: {} }, &quot;mod_policy&quot;: &quot;Admins&quot;, &quot;policies&quot;: { &quot;Admins&quot;: { &quot;policy&quot;: { &quot;type&quot;: 3, &quot;value&quot;: { &quot;rule&quot;: &quot;MAJORITY&quot;, &quot;sub_policy&quot;: &quot;Admins&quot; } } }, &quot;Readers&quot;: { &quot;policy&quot;: { &quot;type&quot;: 3, &quot;value&quot;: { &quot;sub_policy&quot;: &quot;Readers&quot; } } }, &quot;Writers&quot;: { &quot;policy&quot;: { &quot;type&quot;: 3, &quot;value&quot;: { &quot;sub_policy&quot;: &quot;Writers&quot; } } } }, &quot;version&quot;: &quot;1&quot; } }, &quot;values&quot;: { &quot;Consortium&quot;: { &quot;value&quot;: { &quot;name&quot;: &quot;SampleConsortium&quot; } } } } }Note that the Consortium name used must exist on the system channel. All organizations that you wish to add to the new channel must be defined under in the Consortium section with that name on the system channel. Use the decoded genesis block to verify all values, for example by looking in the genesis.json file generated above. To add an organizations to the channel, they must be placed under the groups section under the Applications section as shown above. See that Org1MSP is a property of Applications.groups section. In this example all of the settings for the organization Org1MSP will be inherited from the system channel (notice the empty object &quot;{}&quot; for this organization's properties). To see the current settings for this organization look within the SampleConsortium section under the Consortium section of the system channel (the genesis block of the system channel). Once you have a JSON configuration representing your channel, send it the configtxlator to be encoded into a configuration binary. The following example of sending a REST request to the configtxlator uses the Node.js package superagent because of the ease of use for HTTP requests. var response = superagent.post('http://127.0.0.1:7059/protolator/encode/common.ConfigUpdate', config_json.toString()) .buffer() .end((err, res) =&gt; { if(err) { logger.error(err); return; } config_proto = res.body; });Signing and submitting the channel updateThe binary configuration must be signed by all organizations. The application will have to store the binary configuration and have it available to be signed along with storing all the signatures as it collects them. Then once the signing is complete, the application will send the binary configuration and all the signatures to the orderer using the fabric-client SDK API createChannel(). First the signing, assuming the client fabric-client SDK object has a valid user in a required organization var signature = client.signChannelConfig(config_proto); signatures.push(signature);Now it is time for the channel create, assuming that the signatures object is an array of common.ConfigSignature returned by the client.signChannelConfig() method. Note: The orderer must be started with the genesis.block that was generated from the same configuration file as the initial binary channel configuration definition // create an orderer object to represent the orderer of the network var orderer = client.newOrderer(url,opts); // have the SDK generate a transaction id let tx_id = client.newTransactionID(); request = { config: config_proto, //the binary config signatures : signatures, // the collected signatures name : 'mychannel', // the channel name orderer : orderer, //the orderer from above txId : tx_id //the generated transaction id }; // this call will return a Promise client.createChannel(request)The createChannel API returns a Promise to return the status of the submit. The channel create will take place asynchronously by the orderer. After a small delay of a few seconds the channel will have been created by the orderer and may now be joined by the peers. Issue the following to the peers that are required on the channel. This is a two step process of first getting the genesis block of the channel and then sending it to the peer. In the following example the genesis block was retrieved from the orderer, but could have also been loaded from a file. // set the channel up with network endpoints var orderer = client.newOrderer(orderer_url,orderer_opts); channel.addOrderer(orderer); var peer = client.newPeer(peer_url,peer_opts); channel.addPeer(peer); tx_id = client.newTransactionID(); let g_request = { txId : tx_id }; // get the genesis block from the orderer channel.getGenesisBlock(g_request).then((block) =&gt;{ genesis_block = block; tx_id = client.newTransactionID(); let j_request = { targets : targets, block : genesis_block, txId : tx_id }; // send genesis block to the peer return channel.joinChannel(j_request); }).then((results) =&gt;{ if(results &amp;&amp; results.response &amp;&amp; results.response.status == 200) { // join successful } else { // not good } });This work is licensed under a Creative Commons Attribution 4.0 International License. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"tutorial-channel-events.html":{"id":"tutorial-channel-events.html","title":"Tutorial: How to use the channel-based event service","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER How to use the channel-based event service This tutorial illustrates the use of channel-based events. These events are similar to the existing events, however are specific to a single channel. The client handling of channel-based events has a few new options when setting up a listener. Channel-based events are a new feature of the Hyperledger Fabric Node.js client as of 1.1. For more information on getting started with Hyperledger Fabric see Building your first network. The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), and of Node application development, including the use of the Javascript Promise. OverviewChannel-based events occur when there is a new block added to the channel ledger. A client application may use the Fabric Node.js client to register a listener to receive blocks as they are added to the channel ledger. Channel-based events also allow a client to start to receive blocks from a specific block number, thus allowing the event processing to run normally on blocks that may have been missed. The Fabric Node.js client will also assist client applications by processing the incoming blocks and looking for specific transactions or chaincode events. This allows a client application to be notified of transaction completion or arbitrary chaincode events without having to perform multiple queries or search through the blocks as they are received. If you register for a block event and then submit a transaction, you should not make any assumptions about which block contains your transaction. In particular, you should not assume that your transaction is in the block associated with the first block event received after registration to the peer's channel-based event service. Instead, you may simply register for a transaction event. The Fabric peer channel-based event service allows any user to receive filtered block events which contain no sensitive information. To receive unfiltered block events requires read access to the channel because it returns potentially sensitive information. The default behavior is to connect to receive filtered block events. To connect to receive unfiltered block events call connect(true) (see below). new API on the Channel newChannelEventHub(peer) - A Channel instance method to get a new instance of a ChannelEventHub. getChannelEventHubsForOrg - Gets a list of ChannelEventHubs based on an organization. If the organization name is omitted then the current organization of the current user is used. new class ChannelEventHub and new APIs registerBlockEvent(eventCallBack, errorCallBack, options) - To register for block events. unregisterBlockEvent(reg_num) - To remove a block registration. registerTxEvent(tx_id, eventCallBack, errorCallBack, options) - To register for a specific transaction event. unregisterTxEvent(tx_id) - To remove a specific transaction registration. registerChaincodeEvent(ccid, eventCallBack, errorCallBack, options) - To register for chaincode events. unregisterChaincodeEvent(cc_handle) - To remove a chaincode event registration. connect(full_block) - To have the client channel event hub connect with the fabric channel-based event service. This call must be made before events will be received by your instance of a ChannelEventHub. When the channel-based event hub connects with the service, it will request to receive blocks or filtered blocks. If the 'full_block' parameter is omitted, it will default to false and filtered blocks will be requested. Receiving blocks or filtered blocks can not be changed once the 'connect()' is called. disconnect() - To have the client channel event hub shutdown the connection to the fabric network channel-based event service and notify all current channel event registrations of the shutdown by using the registered errorCallBacks. peer parameterThis parameter must be included when getting a new instance of the ChannelEventHub. The value may be a Peer instance or the name of a peer when using a connection profile see How to use a common network configuration file. eventCallback parameterThis parameter must be included. This is the callback function to be notified when this channel receives a new block, when listening for a specific transaction or chaincode events. errorCallback parameterThis is an optional parameter. This is the callback function to be notified when this channel event hub is shutdown. The shutdown may be caused by a fabric network error, network connection problem or by a call to the &quot;disconnect()&quot; method. options parameterThis is an optional parameter. This parameter will contain the following optional properties: {integer} startBlock - Optional - The starting block number for event checking. When included, the peer's channel-based event service will be asked to start sending blocks from this block number. This is how to resume listening or replay missed blocks that were added to the ledger. The default value is the block number of the last block on the ledger. Replaying events may confuse other event listeners; therefore, only one listener will be allowed on a ChannelEventHub when startBlock and/or endBlock are used. When this parameter is excluded, which would be the normal situation, the fabric channel-based event service will be asked to start sending blocks from the last block on the ledger. {integer} endBlock - Optional - The ending block number for event checking. When included, the peer's channel-based event service will be asked to stop sending blocks once this block is delivered. This is how to replay missed blocks that were added to the ledger. When a startBlock is not included, the endBlock must be equal to or larger than the current channel block height. Replaying events may confuse other event listeners; therefore, only one listener will be allowed on a ChannelEventHub when startBlock and/or endBlock are used. {boolean} unregister - Optional - This options setting indicates the registration should be removed (unregister) when the event is seen. When the application is using a timeout to only wait a specified amount of time for the transaction to be seen, the timeout processing should include the manual 'unregister' of the transaction event listener to avoid the event callbacks being called unexpectedly. The default for this setting is different for the different types of event listeners. For block listeners the default is true when an end_block was set as a option. For transaction listeners the default is true. For chaincode listeners the default will be false as the match filter might be intended for many transactions. {boolean} disconnect - Optional - This option setting Indicates to the ChannelEventHub instance to automatically disconnect itself from the peer's channel-based event service once the event has been seen. The default is false unless the endBlock has been set, then it it will be true. Get a Channel-based Event HubNew methods have been added to the fabric node.js client Channel object to simplify setting up of ChannelEventHub objects. Use the following to get a ChannelEventHub instances that will be setup to work with the peer's channel-based event service. A ChannelEventHub instance will use all the same endpoint configuration settings that the peer instance is using, like the tls certs and the host and port address. When using a connection profile (see) then the peer's name may be used to get a new channel event hub. var channel_event_hub = channel.newChannelEventHub('peer0.org1.example.com');Here is an example of how to get a list of channel event hubs when using a connection profile. The following will get a list based on the current organization that is defined in the currently active client section of the connection profile. Peers defined in the organization that have the eventSource set to true will be added to the list. var channel_event_hubs = channel.getChannelEventHubsForOrg();When creating a peer instance, you can get a ChannelEventHub instance by using the peer instance. let data = fs.readFileSync(path.join(__dirname, 'somepath/tlscacerts/org1.example.com-cert.pem')); let peer = client.newPeer( 'grpcs://localhost:7051', { pem: Buffer.from(data).toString(), 'ssl-target-name-override': 'peer0.org1.example.com' } ); let channel_event_hub = channel.newChannelEventHub(peer);Block ListenerWhen there is a need to monitor for new blocks being added to the channel ledger, use a block event listener. The fabric client Node.js will be notified when a new block is committed to the ledger on the fabric peer. The fabric client Node.js will then call the registered callback of the application program. The callback will be passed a JSON representation of the newly added block. Note that when the connect() is not called with a 'true' value the callback will receive a filtered block. The access rights of the user registering to receive full blocks will be checked by the peer's channel-based event service. When there is a need to see previously added blocks, the registration of the callback may include a starting block number. The callback will start receiving blocks from this number and continue to receive new blocks as they are added to the ledger. This is a way for the application to resume and replay events that may have been lost if the application were to be offline. The application should remember the last block it has processed to avoid replaying the entire ledger. The following example will register a block listener to start receiving blocks. // keep the block_reg to unregister with later if needed block_reg = channel_event_hub.registerBlockEvent((block) =&gt; { console.log('Successfully received the block event'); &lt;do something with the block&gt; }, (error)=&gt; { console.log('Failed to receive the block event ::'+error); &lt;do something with the error&gt; });The following example will register with a start block number because this application needs to resume at a specific block and replay the missed blocks. The application callback will handle the replayed blocks in the same manor like current events. The block listener will continue to receive blocks as they are committed to the ledger on the fabric peer. // keep the block_reg to unregister with later if needed block_reg = channel_event_hub.registerBlockEvent((block) =&gt; { console.log('Successfully received the block event'); &lt;do something with the block&gt; }, (error)=&gt; { console.log('Failed to receive the block event ::'+error); &lt;do something with the error&gt; }, {startBlock:23} );The following example will register with a start block number and an end block. The application needs to replay the missed blocks. The application callback will handle the replayed blocks in the same manor as current events. The block listener will be automatically unregistered and the ChannelEventHub shutdown when the end block event is seen by the listener. The application will not have to handle this housekeeping. block_reg = channel_event_hub.registerBlockEvent((block) =&gt; { console.log('Successfully received the block event'); &lt;do something with the block&gt; }, (error)=&gt; { console.log('Failed to receive the block event ::'+error); &lt;do something with the error&gt; }, // for block listeners, the defaults for unregister and disconnect are true, // so the they are not required to be set in the following example {startBlock:23, endBlock:30, unregister: true, disconnect: true} );Transaction listenerWhen there is a need to monitor for the completion of a transaction on your organization's peer, use a transaction listener. The fabric client Node.js will be notified when a new block is committed to the ledger on the fabric peer. The fabric client Node.js will then check the block for registered transaction identifiers. If a transaction is found then the callback will be notified with the transaction ID, the transaction status, and the block number. Filtered blocks contain the transaction status, so there is no need to connect to the peer's channel-based event service to receive full blocks. Since most non-admin users will not be able to see full blocks, connecting to receive filtered blocks will avoid access issues when those users only need to listen for their transactions to be committed. The following example will show registering a transaction ID within a javascript promise and building another promise for sending the transaction to the orderer. Both promises will be executed together so that the results will be received for both actions together. The default optional setting of unregister is true with a transaction listener. Therefore in the following example the listener that is registered will be automatically unregistered after the listener sees the transaction. let tx_object = client.newTransactionID(); // get the transaction ID string for later use let tx_id = tx_object.getTransactionID(); let request = { targets : targets, chaincodeId: 'my_chaincode', fcn: 'invoke', args: ['doSomething', 'with this data'], txId: tx_object }; return channel.sendTransactionProposal(request); }).then((results) =&gt; { // a real application would check the proposal results console.log('Successfully endorsed proposal to invoke chaincode'); // start block may be null if there is no need to resume or replay let start_block = getBlockFromSomewhere(); let event_monitor = new Promise((resolve, reject) =&gt; { let handle = setTimeout(() =&gt; { // do the housekeeping when there is a problem channel_event_hub.unregisterTxEvent(tx_id); console.log('Timeout - Failed to receive the transaction event'); reject(new Error('Timed out waiting for block event')); }, 20000); channel_event_hub.registerTxEvent((event_tx_id, status, block_num) =&gt; { clearTimeout(handle); //channel_event_hub.unregisterTxEvent(event_tx_id); let the default do this console.log('Successfully received the transaction event'); storeBlockNumForLater(block_num); resolve(status); }, (error)=&gt; { clearTimeout(handle); console.log('Failed to receive the transaction event ::'+error); reject(error); }, // when this `startBlock` is null (the normal case) transaction // checking will start with the latest block {startBlock:start_block} // notice that `unregister` is not specified, so it will default to true // `disconnect` is also not specified and will default to false ); }); let send_trans = channel.sendTransaction({proposalResponses: results[0], proposal: results[1]}); return Promise.all([event_monitor, send_trans]); }).then((results) =&gt; {Chaincode event listenerWhen there is a need to monitor for events that will be posted from within your chaincode, use a chaincode event listener. The fabric client Node.js will be notified when a new block is committed to the ledger on the fabric peer. The fabric client Node.js will then check for registered chaincode patterns within the chaincode event's name field. The registration of the listener includes a regular expression to be used in the check against a chaincode event name. If a chaincode event name is found to match the listener's regular expression then the listener's callback will be notified with the chaincode event, the block number, transaction id, and transaction status. Filtered blocks will not have the chaincode event payload information; it has only the chaincode event name. If the payload information is required, the user must have access to the full block and the channel event hub must be connect(true) to receive the full block events from the peer's channel-based event service. The following example demonstrates registering a chaincode event listener within a javascript promise and building another promise for sending the transaction to the orderer. Both promises will be executed together so that the results will be received for both actions together. If a chaincode event listener is needed for long term monitoring, follow the block listener example above. let tx_object = client.newTransactionID(); let request = { targets : targets, chaincodeId: 'my_chaincode', fcn: 'invoke', args: ['doSomething', 'with this data'], txId: tx_object }; return channel.sendTransactionProposal(request); }).then((results) =&gt; { // a real application would check the proposal results console.log('Successfully endorsed proposal to invoke chaincode'); // Build the promise to register a event listener with the NodeSDK. // The NodeSDK will then send a request to the peer's channel-based event // service to start sending blocks. The blocks will be inspected to see if // there is a match with a chaincode event listener. let event_monitor = new Promise((resolve, reject) =&gt; { let regid = null; let handle = setTimeout(() =&gt; { if (regid) { // might need to do the clean up this listener channel_event_hub.unregisterChaincodeEvent(regid); console.log('Timeout - Failed to receive the chaincode event'); } reject(new Error('Timed out waiting for chaincode event')); }, 20000); regid = channel_event_hub.registerChaincodeEvent(chaincode_id.toString(), '^evtsender*', (event, block_num, txnid, status) =&gt; { // This callback will be called when there is a chaincode event name // within a block that will match on the second parameter in the registration // from the chaincode with the ID of the first parameter. console.log('Successfully got a chaincode event with transid:'+ txnid + ' with status:'+status); // might be good to store the block number to be able to resume if offline storeBlockNumForLater(block_num); // to see the event payload, the channel_event_hub must be conneted(true) let event_payload = event.payload.toString('utf8'); if(event_payload.indexOf('CHAINCODE') &gt; -1) { clearTimeout(handle); // Chaincode event listeners are meant to run continuously // Therefore the default to automatically unregister is false // So in this case we want to shutdown the event listener once // we see the event with the correct payload channel_event_hub.unregisterChaincodeEvent(regid); console.log('Successfully received the chaincode event on block number '+ block_num); resolve('RECEIVED'); } else { console.log('Successfully got chaincode event ... just not the one we are looking for on block number '+ block_num); } }, (error)=&gt; { clearTimeout(handle); console.log('Failed to receive the chaincode event ::'+error); reject(error); } // no options specified // startBlock will default to latest // endBlock will default to MAX // unregister will default to false // disconnect will default to false ); }); // build the promise to send the proposals to the orderer let send_trans = channel.sendTransaction({proposalResponses: results[0], proposal: results[1]}); // now that we have two promises all set to go... execute them return Promise.all([event_monitor, send_trans]); }).then((results) =&gt; {This work is licensed under a Creative Commons Attribution 4.0 International License. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"tutorial-metadata-chaincode.html":{"id":"tutorial-metadata-chaincode.html","title":"Tutorial: How to add CouchDB indexes during chaincode installation","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER How to add CouchDB indexes during chaincode installation This tutorial illustrates the use of adding metadata to your chaincode installation. As of v1.1 the only metadata are the indexes that may be added to a CouchDB state database of your channel ledger. For more information: getting started with Hyperledger Fabric setting up a CouchDB as the state database The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), and of Node application development, including the use of the Javascript Promise. OverviewFabric 1.1 has introduced the capability of defining indexes in a CouchDB state database to help improve performance of your queries made in your chaincode. The index definitions need to be in JSON format and in files with a .json extension. These definitions will be included in the chaincode installation package that is sent to the Fabric peer. Modified API's that allow for metadata client.installChaincode() - There is a new attribute ('metadataPath') that may be included in the installation request. The value of the metadataPath is a string representing the absolute path to the directory structure containing the JSON index files. Installing chaincodeThe following example will install the chaincode 'my_chaincode' and include index files. let targets = buildTargets(); //build the list of peers that will require this chaincode let chaincode_path = path.resolve(__dirname, '../chaincode/src/node_cc/my_chaincode'); let metadata_path = path.resolve(__dirname, '../chaincode/my_indexes'); // send proposal to install var request = { targets: targets, chaincodePath: chaincode_path, metadataPath: metadata_path, // notice this is the new attribute of the request chaincodeId: 'my_chaincode', chaincodeType: 'node', chaincodeVersion: 'v1' }; client.installChaincode(request).then((results) =&gt; { var proposalResponses = results[0]; // check the results }, (err) =&gt; { console.log('Failed to send install proposal due to error: ' + err.stack ? err.stack : err); throw new Error('Failed to send install proposal due to error: ' + err.stack ? err.stack : err); });The following shows the path used as the metadataPath above. This is the required directory structure required under the path. The indexes directory will hold the files with the index definitions. The required directory structure and files with a 'json' extension will be included in the chaincode installation package under the 'META_INF' package directory. 'META-INF' should not be included in your local directory structure. .. &lt;&gt; chaincode │ └─── &lt;&gt; my_indexes // here is where the 'metadataPath' will point to │ └─── &lt;&gt; statedb //starting here are the required directories │ └─── &lt;&gt; couchdb │ └─── &lt;&gt; indexes // this directory will contain the index files index-owner.json // these will be the index files and must index-address.json // have the file extension of 'json'Each index must be defined in its own text file with an extension of *.json and contain the index definition formatted in JSON following the CouchDB index JSON syntax. {&quot;index&quot;:{&quot;fields&quot;:[&quot;docType&quot;,&quot;owner&quot;]},&quot;ddoc&quot;:&quot;indexOwnerDoc&quot;, &quot;name&quot;:&quot;indexOwner&quot;,&quot;type&quot;:&quot;json&quot;}This work is licensed under a Creative Commons Attribution 4.0 International License. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"tutorial-mutual-tls.html":{"id":"tutorial-mutual-tls.html","title":"Tutorial: How to configure mutual TLS","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER How to configure mutual TLS This tutorial illustrates how to use the node SDK APIs to connect to an orderer or peer which has TLS client authentication enabled (aka &quot;mutual TLS&quot;). An orderer has TLS client authentication enabled if the ORDERER_GENERAL_TLS_CLIENTAUTHREQUIRED environment variable is set to true. A peer has TLS client authentication enabled if the CORE_PEER_TLS_CLIENTAUTHREQUIRED environment variable is set to true. Connecting to an orderer or peer with TLS client authentication enabledWhen creating an orderer, specify the clientKey and clientCert options with a value equal to the PEM-encoded private key and certificate, respectively. For example, the following demonstrates how to connect to an orderer which has TLS client authentication enabled. This assumes that the client's PEM-encoded TLS key and certificate are at somepath/tls/client.key and somepath/tls/client.crt, respectively. let serverCert = fs.readFileSync(path.join(__dirname, 'somepath/msp/tlscacerts/example.com-cert.pem')); let clientKey = fs.readFileSync(path.join(__dirname, 'somepath/tls/client.key')); let clientCert = fs.readFileSync(path.join(__dirname, 'somepath/tls/client.crt')); orderer = client.newOrderer( 'grpcs://localhost:7050', { 'pem': Buffer.from(serverCert).toString(), 'clientKey': Buffer.from(clientKey).toString(), 'clientCert': Buffer.from(clientCert).toString(), });Similarly, the following demonstrates how to connect to a peer which has TLS client authentication enabled. This assumes that the client's PEM-encoded TLS key and certificate are at somepath/tls/client.key and somepath/tls/client.crt, respectively. let serverCert = fs.readFileSync(path.join(__dirname, 'somepath/msp/tlscacerts/org1.example.com-cert.pem')); let clientKey = fs.readFileSync(path.join(__dirname, 'somepath/tls/client.key')); let clientCert = fs.readFileSync(path.join(__dirname, 'somepath/tls/client.crt')); let peer = client.newPeer( 'grpcs://localhost:7051', { 'pem': Buffer.from(serverCert).toString(), 'clientKey': Buffer.from(clientKey).toString(), 'clientCert': Buffer.from(clientCert).toString(), } ); × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "},"tutorial-network-config.html":{"id":"tutorial-network-config.html","title":"Tutorial: How to use a common connection profile","body":" Hyperledger Fabric SDK for node.js Modules api Classes AffiliationServiceBaseClientBasePackagerBlockDecoderCertificateAuthorityChannelChannelEventHubClientCouchDBKeyValueStoreCryptoKeyStoreCryptoSuite_ECDSA_AESCryptoSuite_PKCS11ECDSA_KEYEndorsementPolicyEventHubFabricCAClientFabricCAServicesFileKeyValueStoreIdentityIdentityServicemodule.exports#module.exportsapi.CryptoSuiteapi.Keyapi.KeyValueStoreMSPMSPManagerNetworkConfig_1_0OrdererOrganizationPeerPKCS11_ECDSA_KEYRemoteSignerSigningIdentityTransactionIDUser Tutorials Setting up the Application Developer's EnvironmentHow to create a Hyperledger Fabric channelHow to use the channel-based event serviceHow to add CouchDB indexes during chaincode installationHow to configure mutual TLSHow to use a common connection profile Global CLIENTHFAFFILIATIONMGRHFGENCRLHFINTERMEDIATECAHFREGISTRARATTRIBUTESHFREGISTRARDELEGATEROLESHFREGISTRARROLESHFREVOKERORDERERpackagePEERUSER How to use a common connection profile This tutorial illustrates the use of common connection profiles. Connection profiles are a new feature of the Hyperledger Fabric Node.js Client as of 1.1. A connection profile will describe the Hyperledger Fabric network to the Hyperledger Fabric Node.js Client (fabric client). For more information on: getting started with Hyperledger Fabric see Building your first network. the configuration of a channel in Hyperledger Fabric and the internal process of creating and updating see Hyperledger Fabric channel configuration cryptographic generation see cryptogen configuration transaction generator see configtxgen configuration translation tool see configtxlator The following assumes an understanding of the Hyperledger Fabric network (orderers and peers), and of Node application development, including the use of the Javascript Promise. OverviewA connection profile contain entries that describe the Hyperledger Fabric network including entries that describe the fabric client that will access the the network. The application will load a configuration file and then it will be used by fabric client to simplify the steps needed to setup and use the network. The connection profile has specific addresses and settings of network items. Resources like javascript classes to instantiate are stored in the fabric client's configuration system. It will be easier to work with a fabric client loaded with a connection profile configuration because it reduces the setup before calling an action. Parameters for items like targets may be specified by name and object will not have to be created and maintained before the action is called. On many calls if no target peer is specified, the fabric client will look to see if there is a Peer in the role needed for the action. API's to load a connection profile Client.loadFromConfig() - A static utility method to get a fabric client instance loaded with the connection profile configuration. client.loadFromConfig() - A fabric client instance method to load a connection profile configuration, overriding any existing connection profile configuration settings that may have been set when this client object was created by the call above. new API's that use a loaded connetion profile client.initCredentialStores() - A fabric client instance method to create a state store and assign it to the fabric client instance based on the current settings in the loaded connection profile configuration. It will also create the crypto suite and assign it to the fabric client instance. A crypto store will be created and assigned to crypto suite if needed. (HSM based crypto suites do not require a crypto store). client.setTlsClientCertAndKey(clientCert, clientKey) -A fabric client instance method that will set a certificate and the corresponding private key on the client instance. Mutual TLS client settings are not stored within the connection profile. When a peer or orderer instance is created for the user from the endpoints defined in the connection profile, these settings will be used as the client mutual TLS settings. When using mutual TLS and a connection profile, this method must be called before endpoints are required. Calling this method is only required when using mutual TLS and a connection profile. channel.newChannelEventHub() - A fabric channel instance method to create an channel-based event hub based on the current settings in the loaded connection profile configuration of the named peer. channel.getChannelEventHubsForOrg() - A fabric channel instance method to return a list of channel-based event hubs that are associated with an organizations. Peers in an organizations that have the eventSource set to true will be returned. client.getPeersForOrg() - A fabric client instance method to return a list of peer objects that are associated with an organizations. Modified API's that will use the connection profile configuration if one has been loaded client.getChannel() - A fabric client instance method that will create a channel instance object based on the settings for a channel defined in the currently loaded connection profile configuration. client.newTransactionID(&lt;boolean&gt;) - This method was modified to allow for a boolean to indicate that the transaction id generated should be based on the administrative identity if one has been assigned rather than the user context assigned to the fabric client. client.setUserContext() - Now allows username and password as a parameter or a User object. When username and password are used the fabric client will perform an enroll with the certificate authority using the username and password. client.installChaincode() - If the targets parameter is excluded from the request parameter list then the peers defined in the current organization of the client will be used. client.queryXXXX() - The query API's will now take a peer name (as defined in the connection profile config) or peer object instance as the target. channel.instantiateChaincode() - If the targets parameter is excluded from the request parameter list then the peers defined in the current organization of the client that are also on this channel will be used. channel.sendTransactionProposal() The request object parameter may use names for targets or let the fabric client find peers to use for targets as defined in the connection profile configuration. channel.sendTransaction() The request object parameter may use orderer name or let the fabric client find an orderer to use as defined in the connection profile configuration. channel.queryXXXX() - All the query API's will now take a peer name as the target rather than an peer instance object. Loading connection profile configurationsThe application code can either point to a yaml or json file that contains the configuration information or it may pass a Javascript object directory to the API's to load a configuration. For convenience there is a static utility method on the fabric-client to create a new fabric client object and load a connection profile configuration at the same time. There is also a method on the fabric client instance that may be used to load a connection profile configuration on top of an existing connection profile configuration. The following example will create a new instance of the fabric-client and load a connection profile configuration. However in this case the connection profile configuration does not contain any information about the client side of the fabric network, just the fabric network elements. var client = Client.loadFromConfig('test/fixtures/network.yaml');Here is the connection profile definition loaded name: &quot;Network&quot; version: &quot;1.0&quot; channels: mychannel: orderers: - orderer.example.com peers: peer0.org1.example.com: endorsingPeer: true chaincodeQuery: true ledgerQuery: true eventSource: true peer0.org2.example.com: endorsingPeer: true chaincodeQuery: false ledgerQuery: true eventSource: false organizations: Org1: mspid: Org1MSP peers: - peer0.org1.example.com certificateAuthorities: - ca-org1 adminPrivateKey: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/keystore/9022d671ceedbb24af3ea69b5a8136cc64203df6b9920e26f48123fcfcb1d2e9_sk signedCert: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/users/Admin@org1.example.com/signcerts/Admin@org1.example.com-cert.pem Org2: mspid: Org2MSP peers: - peer0.org2.example.com certificateAuthorities: - ca-org2 adminPrivateKey: path: test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/keystore/5a983ddcbefe52a7f9b8ee5b85a590c3e3a43c4ccd70c7795bec504e7f74848d_sk signedCert: path: test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/users/Admin@org2.example.com/signcerts/Admin@org2.example.com-cert.pem orderers: orderer.example.com: url: grpcs://localhost:7050 grpcOptions: ssl-target-name-override: orderer.example.com grpc-max-send-message-length: 15 tlsCACerts: path: test/fixtures/channel/crypto-config/ordererOrganizations/example.com/orderers/orderer.example.com/tlscacerts/example.com-cert.pem peers: peer0.org1.example.com: url: grpcs://localhost:7051 eventUrl: grpcs://localhost:7053 grpcOptions: ssl-target-name-override: peer0.org1.example.com grpc.keepalive_time_ms: 600000 tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tlscacerts/org1.example.com-cert.pem peer0.org2.example.com: url: grpcs://localhost:8051 eventUrl: grpcs://localhost:8053 grpcOptions: ssl-target-name-override: peer0.org2.example.com tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/peers/peer0.org2.example.com/tlscacerts/org2.example.com-cert.pem certificateAuthorities: ca-org1: url: https://localhost:7054 httpOptions: verify: false tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/ca/org1.example.com-cert.pem registrar: - enrollId: admin enrollSecret: adminpw caName: caorg1 ca-org2: url: https://localhost:8054 httpOptions: verify: false tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org2.example.com/ca/org2.example.com-cert.pem registrar: - enrollId: admin enrollSecret: adminpw caName: caorg2The following example will have an existing fabric client load a connection profile configuration. The definition will only contain client side definitions and no fabric network definitions. Calling for a load on an existing fabric client does an overlay of the top level sections in the file being loaded replacing the sections on those previously loaded. In this case the file being loaded only has a client section, therefore the loaded definition will now have the perviously loaded channels, organizations, peers, orderers, and certificateAuthorities section definitions and the newly loaded client section definition. This allows for an existing fabric client to be able to work within different organization. client.loadFromConfig('test/fixtures/org1.yaml');Here is the client definition loaded above name: &quot;Org1 Client&quot; version: &quot;1.0&quot; client: organization: Org1 credentialStore: path: &quot;/tmp/hfc-kvs/org1&quot; cryptoStore: path: &quot;/tmp/hfc-cvs/org1&quot;Setup the storesThe next step is to set up the client object with the state and crypto stores. If the client section of the connection profile configuration has these defined then it is a simple matter of running the following. This API is promise based, notice that we will need a .then on the returned promise to have it actually execute. This API does not return anything, however it has created a state store and assigned it to the client, it has created a CryptoSuite and also assigned it to the client, and created a crypto store and assigned that to the crypto suite. Notice the credentialStore and cryptoStore definitions above in the client section of the connection profile configuration. In this case we are using two different locations, it may be easier to have these in the same locations when first starting out. The following will create two stores and a CryptoSuite and assign them to the fabric client all based on the loaded configurations. client.initCredentialStores() .then((nothing) =&gt; {Work with user contextWhen there is certificate Authority information on the organization, the fabric client may be used to simplify the enrollment and user context creation. The application will still have to register new users with the certificate authority, however when a connection profile configuration has been loaded there a simpler way to get a certificate authority client. So first let's enroll an admin user so that we have the credentials (crypto material) needed to interact with the certificate authority and the fabric network. The following convenience method will first look in the state store (as defined above) to see if the user exist. If the user is not found and there is a connection profile configuration loaded, the fabric client will build a certificate authority client object as defined in the fabric client configuration with the address as defined in the currently loaded connection profile configuration. The fabric client uses the certificate authority client to enroll the admin user with the certificate authority, this requires that a new set of keys be generated on the client side. The fabric client will then use the signed certificate returned by the certificate authority from the enroll to create a user context. The context will then be assign it to fabric client and stored in the state store along with storing the keys in the crypto store. At this point the fabric client is ready to interact with the fabric network and the application may use the returned user object to interact with the certificate authority. In the following example we are able to enroll the user because it known by the certificate authority. New users will have to be registered first. client.setUserContext({username:'admin', password:'adminpw'}) .then((admin) =&gt; {The following example will have the fabric client build a certificate authority client based on the currently loaded connection profile configuration by first finding which organization defined in the client section and then finding the certificate authority associated with that organization. var fabric_ca_client = client.getCertificateAuthority();Then once we have a fabric-ca-client, we will be able to register new users. We could also use the fabric-ca-client to enroll users and make a few calls to the fabric client to create a user object and then assign that user object to the fabric client, but it will be much easier to just use the convenience method of the fabric client instance. Notice how we have to use the 'admin' user object returned from the client.setUserContext() to do the register. The admin user object has the credentials needed to the register. Then notice we called the same setUserContext method as we did with the admin above, this will have the fabric client object assigned with the 'user1' user context thus providing the credentials to interact with the fabric network. Note that the setUserContext also stores the user context which contains the signed certificate from the certificate authority and newly created public and private keys of the now enrolled user. ca.fabric_ca_client({enrollmentID: 'user1', affiliation: 'org1'}, admin) .then((secret) =&gt; { return client.setUserContext({username:'user1', password:secret}); }).then((user)=&gt; {Work with mutual TLSWhen your network configuration includes mutual TLS, the client certificate and private key must be available to the client instance before the endpoints are automatically built. The client instance will be able to pass the required material to the endpoint instance that is needed to establish the connection. The example shown will also retrieve the material. These steps must be performed before any actions on the fabric network. // get the CA associated with this client's organization let fabric_ca_client = client.getCertificateAuthority(); let request = { enrollmentID: 'user1', enrollmentSecret: secret, profile: 'tls' }; // make the request to build the keys and get the certificate fabric_ca_client.enroll(request) .then((enrollment) =&gt; { // Successfully called the Certificate Authority to get the TLS material let key = enrollment.key.toBytes(); let cert = enrollment.certificate; // set the material on the client to be used when building endpoints for the user client.setTlsClientCertAndKey(cert, key); ...When an admin is neededNotice in the organizations section of the connection profile configuration that an organization may have a signed cert setting and admin private key setting that are associated with the organization. This is a convenience for your organization such that operations that require a fabric network administrator will be able to get one easily. These credentials will be assigned to the fabric client when the configuration is loaded. If one has not been assigned than the current user context assigned to the fabric client is assumed to be an administrator. There is also a convenience method on the client object that will assign credentials to the client to be used for operations that require an admin. client.setAdminSigningIdentity('admin privateKey','admin cert');Assume that connection profile configurations have been loaded, setting up both an organization with an admin and indicating that the client is in that organization. Then when the call is made to get a transaction id object, the fabric client will check to see if an admin has been assigned to the fabric client and use that to generate the transaction id. The transaction id returned will be tagged that it was generated with the assigned administrative identity. Notice how the request object being built is using just a name for the orderer rather than a Orderer object. The fabric client will look up this name in the loaded connection profile configuration. When the createChannel call is made, the fabric client will know that this action should be signed by the administrative identity because the transaction id was marked as an admin based transaction. Note that the administrative signing identity is not required if the logged in user is an administrative user and has been assigned to the fabric client. let tx_id = client.newTransactionID(true); let request = { config: config, signatures : signatures, name : channel_name, orderer : 'orderer.example.com', txId : tx_id }; return client.createChannel(request); }).then((result) =&gt; {When a peer is neededNotice how a peer is added to an organization, it is more than just a reference to the actual peer definition, the peer is also defined to have roles within that organization. peer0.org2.example.com: endorsingPeer: true chaincodeQuery: false ledgerQuery: true eventSource: false This peer may be used to endorse transaction, but not used to run chaincode queries. This peer may be used to audit the channel by making ledger based queries (like queryBlock), but may not be used to be an event source. Of course this combination of roles does not make much sense in real life. So let's have a look at a chaincode invoke endorsement let tx_id = client.newTransactionID(); var request = { chaincodeId : 'example', fcn: 'move', args: ['a', 'b','100'], txId: tx_id }; channel.sendTransactionProposal(request) .then((results) =&gt; {Notice that we have left off the targets parameter of the request object. This will have the fabric client do a lookup of peers on this channel in the connection profile configuration. The fabric client will be looking for peers defined in the role of endorsingPeer. The fabric client will then send the proposal to the located peers and return all the endorsements in the results object. There may be a need to have only the peers in a specific organization. var peers = getPeersForOrg('Org1');Or maybe for the organization that is defined in the client section of the connection profile. var peers = getPeersForOrg();When an orderer is neededAfter receiving endorsements from the peers for a transaction proposal, they will need to be sent to an orderer along with the proposal for a transaction to be committed to the ledger. var request = { proposalResponses: proposalResponses, proposal: proposal }; channel.sendTransaction(request) .then((results) =&gt; {Notice that an orderer to send this transaction to is not included in the request object. The orderer defined in the connection profile configuration will be used. When doing queriesWhen there is a connection profile configuration loaded and the query call is not passed a target peer to use, the fabric client will look in the connection profile configuration for a peer to use. These are fabric client based queries and require the user have an admin role or indicate that the admin identity should be used. These queries do not use the connection profile config lookup to find a peer to use and must be passed the target peer. queryChannels queryInstalledChaincodes These queries are channel based queries that require a peer with the ledgerQuery role. queryInstantiatedChaincodes (user must be an admin or indicate that the assigned admin identity should be used) queryInfo queryBlockByHash queryBlock queryTransaction this is a channel based query and requires a peer with the chaincodeQuery role. queryByChaincode When monitoring for eventsWorking with an channel-based event hub will not changed when a connection profile configuration has been loaded. A new method has been added to the fabric client to simplify setting up of an ChannelEventHub object. Use the following to get an ChannelEventHub object that will be setup to work with the named peer's channel-based event hub. var chanel_event_hub = channel.newChannelEventHub('peer0.org1.example.com');Notice how the parameter to the call is the name of the peer. All settings to create an channel-based event hub are defined by the connection profile configuration under the peer by that name. peer0.org1.example.com: url: grpcs://localhost:7051 grpcOptions: ssl-target-name-override: peer0.org1.example.com grpc.keepalive_time_ms: 600000 tlsCACerts: path: test/fixtures/channel/crypto-config/peerOrganizations/org1.example.com/peers/peer0.org1.example.com/tlscacerts/org1.example.com-cert.pemThe following will be a list of event hubs that are within the 'Org1' organization. All peers referenced by an organization that the 'eventSource' set to true. var channel_event_hubs = channel.getChannelEventHubsForOrg('Org1');The following will be a list of channel-based event hubs that are within the organization defined in the client section of the connection profile. var channel_event_hubs = channel.getChannelEventHubsForOrg();This work is licensed under a Creative Commons Attribution 4.0 International License. × Search results Close Documentation generated by JSDoc 3.5.5 on 2018-03-23T19:02:05+00:00 using the DocStrap template. "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
